[
  {
    "id": 1,
    "node_type": "Repository",
    "version": 1,
    "sequence": 1,
    "enabled": true,
    "input_sources": "{\"files\": [], \"nodes\": []}",
    "instruction": "Extract repository metadata including name, URL, branch, and commit hash from the repository root.",
    "example": "{\"repoName\": \"my-repo\", \"url\": \"https://github.com/user/my-repo\", \"branch\": \"main\", \"commit\": \"abc123\", \"confidence\": 1.0}",
    "is_active": true,
    "extraction_method": "structural",
    "temperature": 0.30000001192092896,
    "max_tokens": 1000,
    "created_at": "2025-11-07T10:15:44.067130"
  },
  {
    "id": 2,
    "node_type": "Directory",
    "version": 1,
    "sequence": 2,
    "enabled": true,
    "input_sources": "{\"files\": [], \"nodes\": [\"Repository\"]}",
    "instruction": "Extract directory structure from {{repository}}. Create a node for each directory in the hierarchy.",
    "example": "{\"name\": \"src\", \"path\": \"my-repo/src\", \"confidence\": 1.0}",
    "is_active": true,
    "extraction_method": "structural",
    "temperature": 0.30000001192092896,
    "max_tokens": 1000,
    "created_at": "2025-11-07T10:15:44.069517"
  },
  {
    "id": 3,
    "node_type": "File",
    "version": 1,
    "sequence": 3,
    "enabled": true,
    "input_sources": "{\"files\": [{\"type\": \"source\", \"subtype\": \"*\"}, {\"type\": \"config\", \"subtype\": \"*\"}, {\"type\": \"docs\", \"subtype\": \"*\"}, {\"type\": \"test\", \"subtype\": \"*\"}, {\"type\": \"build\", \"subtype\": \"*\"}, {\"type\": \"data\", \"subtype\": \"*\"}], \"nodes\": [\"Directory\"]}",
    "instruction": "Extract individual files from {{input_directories}}, classify by type using the file type registry, and calculate basic metrics. Group similar files into patterns when detected (e.g., data_[N].json).\n\nExample: {{example}}",
    "example": "{\"fileName\": \"auth.py\", \"filePath\": \"src/auth/auth.py\", \"fileType\": \"source\", \"subtype\": \"python\", \"size\": 2048, \"complexityScore\": 0.6, \"confidence\": 1.0}",
    "is_active": true,
    "extraction_method": "structural",
    "temperature": 0.30000001192092896,
    "max_tokens": 1000,
    "created_at": "2025-11-07T10:15:44.072212"
  },
  {
    "id": 4,
    "node_type": "BusinessConcept",
    "version": 1,
    "sequence": 4,
    "enabled": true,
    "input_sources": "{\"files\": [{\"type\": \"docs\", \"subtype\": \"*\"}], \"nodes\": [\"File\"]}",
    "instruction": "Extract ONLY high-level business domain concepts from the documentation.\n\nWHAT TO EXTRACT:\nBusiness domain concepts are the core entities, actors, processes, and events that define the problem domain - NOT the technical solution.\n\nCATEGORIZATION RULES:\n1. ENTITIES: Nouns representing data the business manages\n2. ACTORS: Roles that interact with the system (not User/Admin)\n3. PROCESSES: Workflows that transform or move data\n4. EVENTS: State changes with business significance\n\nNAMING RULES (MANDATORY):\n- Use SINGULAR form (Entity not Entities)\n- Use CamelCase for multi-word names\n- Use domain terminology from the code\n- Include context prefix if needed for disambiguation\n\nEXCLUDE ALL:\n- Framework names, libraries, tools\n- Technical operations (CRUD, API, query)\n- Infrastructure concepts (server, database, cache)\n- Generic actors (User, Admin, System)\n- Implementation details\n\nSELECTION CRITERIA:\n- Confidence >= 0.7 required\n- Maximum 5-7 concepts per file\n- Prefer concepts that appear multiple times in code\n\nOutput stable, deterministic results.",
    "example": "{\"conceptName\": \"Invoice\", \"conceptType\": \"entity\", \"description\": \"Document representing a billing transaction with line items and payment terms\", \"originSource\": \"docs/readme.md\", \"confidence\": 0.9}",
    "is_active": false,
    "extraction_method": "llm",
    "temperature": 0.30000001192092896,
    "max_tokens": 2000,
    "created_at": "2025-11-07T10:15:44.074751"
  },
  {
    "id": 11,
    "node_type": "BusinessConcept",
    "version": 2,
    "sequence": 4,
    "enabled": true,
    "input_sources": "{\"files\": [{\"type\": \"docs\", \"subtype\": \"*\"}], \"nodes\": [\"File\"]}",
    "instruction": "Extract ONLY high-level business domain concepts from the documentation.\n\nWHAT TO EXTRACT:\nBusiness domain concepts are the core entities, actors, processes, and events that define the problem domain - NOT the technical solution.\n\nCATEGORIZATION RULES:\n1. ENTITIES: Nouns representing data the business manages\n2. ACTORS: Roles that interact with the system (not User/Admin)\n3. PROCESSES: Workflows that transform or move data\n4. EVENTS: State changes with business significance\n\nNAMING RULES (MANDATORY):\n- Use SINGULAR form (Entity not Entities)\n- Use CamelCase for multi-word names\n- Use domain terminology from the code\n- Include context prefix if needed for disambiguation\n\nEXCLUDE ALL:\n- Framework names, libraries, tools\n- Technical operations (CRUD, API, query)\n- Infrastructure concepts (server, database, cache)\n- Generic actors (User, Admin, System)\n- Implementation details\n\nSELECTION CRITERIA:\n- Confidence >= 0.7 required\n- Maximum 5-7 concepts per file\n- Prefer concepts that appear multiple times in code\n\nOutput stable, deterministic results.",
    "example": "{\"conceptName\": \"Invoice\", \"conceptType\": \"entity\", \"description\": \"Document representing a billing transaction with line items and payment terms\", \"originSource\": \"docs/readme.md\", \"confidence\": 0.9}",
    "is_active": true,
    "extraction_method": "llm",
    "temperature": 0.30000001192092896,
    "max_tokens": 4000,
    "created_at": "2026-01-08T10:30:54.201302"
  },
  {
    "id": 5,
    "node_type": "Technology",
    "version": 1,
    "sequence": 5,
    "enabled": true,
    "input_sources": "{\"files\": [{\"type\": \"dependency\", \"subtype\": \"*\"}, {\"type\": \"config\", \"subtype\": \"*\"}, {\"type\": \"build\", \"subtype\": \"*\"}], \"nodes\": []}",
    "instruction": "Extract technology stack components from the source file.\n\nWHAT TO EXTRACT:\nTechnologies are frameworks, libraries, and tools that provide technical capabilities - NOT business concepts.\n\nCATEGORIZATION:\n1. FRAMEWORKS: Web frameworks, ORM frameworks, testing frameworks\n2. LIBRARIES: Utility libraries, data processing libraries\n3. TOOLS: Build tools, development tools, deployment tools\n\nNAMING RULES (MANDATORY):\n1. Use the canonical package name from the ecosystem\n2. Use lowercase for all identifiers\n3. Group related packages under parent technology\n\nSELECTION CRITERIA:\n- Confidence >= 0.7 required\n- Prefer technologies explicitly imported/declared\n- Exclude transitive dependencies\n\nEXCLUDE:\n- Standard library modules\n- Internal project modules\n- Type stubs and development-only tools\n\nLIMIT: Maximum 5-7 technologies per file.\n\nOutput stable, deterministic results.",
    "example": "{\"techName\": \"PostgreSQL\", \"techCategory\": \"system_software\", \"description\": \"Primary relational database for application data\", \"version\": \"15\", \"confidence\": 0.95}",
    "is_active": false,
    "extraction_method": "llm",
    "temperature": 0.30000001192092896,
    "max_tokens": 2000,
    "created_at": "2025-11-07T10:15:44.077081"
  },
  {
    "id": 12,
    "node_type": "Technology",
    "version": 2,
    "sequence": 5,
    "enabled": true,
    "input_sources": "{\"files\": [{\"type\": \"dependency\", \"subtype\": \"*\"}, {\"type\": \"config\", \"subtype\": \"*\"}, {\"type\": \"build\", \"subtype\": \"*\"}], \"nodes\": []}",
    "instruction": "Extract technology stack components from the source file.\n\nWHAT TO EXTRACT:\nTechnologies are frameworks, libraries, and tools that provide technical capabilities - NOT business concepts.\n\nCATEGORIZATION:\n1. FRAMEWORKS: Web frameworks, ORM frameworks, testing frameworks\n2. LIBRARIES: Utility libraries, data processing libraries\n3. TOOLS: Build tools, development tools, deployment tools\n\nNAMING RULES (MANDATORY):\n1. Use the canonical package name from the ecosystem\n2. Use lowercase for all identifiers\n3. Group related packages under parent technology\n\nSELECTION CRITERIA:\n- Confidence >= 0.7 required\n- Prefer technologies explicitly imported/declared\n- Exclude transitive dependencies\n\nEXCLUDE:\n- Standard library modules\n- Internal project modules\n- Type stubs and development-only tools\n\nLIMIT: Maximum 5-7 technologies per file.\n\nOutput stable, deterministic results.",
    "example": "{\"techName\": \"PostgreSQL\", \"techCategory\": \"system_software\", \"description\": \"Primary relational database for application data\", \"version\": \"15\", \"confidence\": 0.95}",
    "is_active": true,
    "extraction_method": "llm",
    "temperature": 0.30000001192092896,
    "max_tokens": 4000,
    "created_at": "2026-01-08T10:31:11.379184"
  },
  {
    "id": 6,
    "node_type": "ExternalDependency",
    "version": 1,
    "sequence": 6,
    "enabled": true,
    "input_sources": "{\"files\": [{\"type\": \"dependency\", \"subtype\": \"*\"}, {\"type\": \"config\", \"subtype\": \"*\"}, {\"type\": \"source\", \"subtype\": \"*\"}], \"nodes\": []}",
    "instruction": "Extract external dependencies from package manifests and import statements.\n\nWHAT TO EXTRACT:\nThird-party packages and libraries that the project depends on.\n\nNAMING RULES (MANDATORY):\n1. Use the canonical PyPI/npm package name\n2. Use lowercase identifiers\n3. Do NOT include version numbers in names\n\nSELECTION CRITERIA:\n- Include: Direct dependencies (listed in requirements/package.json)\n- Include: Imported packages in source files\n- Exclude: Standard library modules\n- Exclude: Internal project modules\n\nGROUPING:\n- Group related packages (e.g., flask + flask-wtf = flask ecosystem)\n- Identify primary package vs extensions\n\nLIMIT: Maximum 15 dependencies per file.\n\nOutput stable, deterministic results.",
    "example": "{\"dependencyName\": \"Stripe\", \"dependencyCategory\": \"external_api\", \"version\": \"5.0.0\", \"ecosystem\": \"pypi\", \"description\": \"Payment processing API client\", \"confidence\": 0.95}",
    "is_active": false,
    "extraction_method": "llm",
    "temperature": 0.30000001192092896,
    "max_tokens": 1500,
    "created_at": "2025-11-07T10:15:44.079380"
  },
  {
    "id": 13,
    "node_type": "ExternalDependency",
    "version": 2,
    "sequence": 6,
    "enabled": true,
    "input_sources": "{\"files\": [{\"type\": \"dependency\", \"subtype\": \"*\"}, {\"type\": \"config\", \"subtype\": \"*\"}, {\"type\": \"source\", \"subtype\": \"*\"}], \"nodes\": []}",
    "instruction": "Extract external dependencies from package manifests and import statements.\n\nWHAT TO EXTRACT:\nThird-party packages and libraries that the project depends on.\n\nNAMING RULES (MANDATORY):\n1. Use the canonical PyPI/npm package name\n2. Use lowercase identifiers\n3. Do NOT include version numbers in names\n\nSELECTION CRITERIA:\n- Include: Direct dependencies (listed in requirements/package.json)\n- Include: Imported packages in source files\n- Exclude: Standard library modules\n- Exclude: Internal project modules\n\nGROUPING:\n- Group related packages (e.g., flask + flask-wtf = flask ecosystem)\n- Identify primary package vs extensions\n\nLIMIT: Maximum 15 dependencies per file.\n\nOutput stable, deterministic results.",
    "example": "{\"dependencyName\": \"Stripe\", \"dependencyCategory\": \"external_api\", \"version\": \"5.0.0\", \"ecosystem\": \"pypi\", \"description\": \"Payment processing API client\", \"confidence\": 0.95}",
    "is_active": false,
    "extraction_method": "llm",
    "temperature": 0.30000001192092896,
    "max_tokens": 4000,
    "created_at": "2026-01-08T10:31:27.180795"
  },
  {
    "id": 15,
    "node_type": "ExternalDependency",
    "version": 3,
    "sequence": 6,
    "enabled": true,
    "input_sources": "{\"files\": [{\"type\": \"dependency\", \"subtype\": \"*\"}, {\"type\": \"config\", \"subtype\": \"*\"}]}",
    "instruction": "Extract external dependencies from package manifests and import statements.\n\nWHAT TO EXTRACT:\nThird-party packages and libraries that the project depends on.\n\nNAMING RULES (MANDATORY):\n1. Use the canonical PyPI/npm package name\n2. Use lowercase identifiers\n3. Do NOT include version numbers in names\n\nSELECTION CRITERIA:\n- Include: Direct dependencies (listed in requirements/package.json)\n- Include: Imported packages in source files\n- Exclude: Standard library modules\n- Exclude: Internal project modules\n\nGROUPING:\n- Group related packages (e.g., flask + flask-wtf = flask ecosystem)\n- Identify primary package vs extensions\n\nLIMIT: Maximum 15 dependencies per file.\n\nOutput stable, deterministic results.",
    "example": "{\"dependencyName\": \"Stripe\", \"dependencyCategory\": \"external_api\", \"version\": \"5.0.0\", \"ecosystem\": \"pypi\", \"description\": \"Payment processing API client\", \"confidence\": 0.95}",
    "is_active": true,
    "extraction_method": "llm",
    "temperature": 0.30000001192092896,
    "max_tokens": 4000,
    "created_at": "2026-01-12T07:30:36.714054"
  },
  {
    "id": 7,
    "node_type": "TypeDefinition",
    "version": 1,
    "sequence": 7,
    "enabled": true,
    "input_sources": "{\"files\": [{\"type\": \"source\", \"subtype\": \"*\"}], \"nodes\": []}",
    "instruction": "Extract type definitions (classes, structs, interfaces) from source code.\n\nWHAT TO EXTRACT:\nType definitions that represent data structures, models, or contracts in the codebase.\n\nNAMING RULES (MANDATORY):\n1. Use the exact class/type name as defined in code\n2. Preserve original casing (PascalCase, snake_case as found)\n3. Include module prefix if needed for disambiguation\n\nSELECTION CRITERIA:\n- Include: Classes, dataclasses, TypedDict, NamedTuple, Protocols\n- Include: Database models, API schemas, domain entities\n- Exclude: Test fixtures, mock classes, abstract base classes without implementations\n\nLIMIT: Maximum 10 type definitions per file.\n\nOutput stable, deterministic results.",
    "example": "{\"typeName\": \"UserRepository\", \"category\": \"class\", \"description\": \"Data access layer for User entities\", \"interfaceType\": \"Internal API\", \"startLine\": 15, \"endLine\": 45, \"confidence\": 0.9}",
    "is_active": false,
    "extraction_method": "llm",
    "temperature": 0.30000001192092896,
    "max_tokens": 3000,
    "created_at": "2025-11-07T10:15:44.081679"
  },
  {
    "id": 10,
    "node_type": "TypeDefinition",
    "version": 2,
    "sequence": 7,
    "enabled": true,
    "input_sources": "{\"files\": [{\"type\": \"source\", \"subtype\": \"*\"}], \"nodes\": []}",
    "instruction": "Extract type definitions (classes, structs, interfaces) from source code.\n\nWHAT TO EXTRACT:\nType definitions that represent data structures, models, or contracts in the codebase.\n\nNAMING RULES (MANDATORY):\n1. Use the exact class/type name as defined in code\n2. Preserve original casing (PascalCase, snake_case as found)\n3. Include module prefix if needed for disambiguation\n\nSELECTION CRITERIA:\n- Include: Classes, dataclasses, TypedDict, NamedTuple, Protocols\n- Include: Database models, API schemas, domain entities\n- Exclude: Test fixtures, mock classes, abstract base classes without implementations\n\nLIMIT: Maximum 10 type definitions per file.\n\nOutput stable, deterministic results.",
    "example": "{\"typeName\": \"UserRepository\", \"category\": \"class\", \"description\": \"Data access layer for User entities\", \"interfaceType\": \"Internal API\", \"startLine\": 15, \"endLine\": 45, \"confidence\": 0.9}",
    "is_active": false,
    "extraction_method": "llm",
    "temperature": 0.30000001192092896,
    "max_tokens": 3000,
    "created_at": "2026-01-02T16:56:32.657927"
  },
  {
    "id": 14,
    "node_type": "TypeDefinition",
    "version": 3,
    "sequence": 7,
    "enabled": true,
    "input_sources": "{\"files\": [{\"type\": \"source\", \"subtype\": \"*\"}], \"nodes\": []}",
    "instruction": "Extract type definitions (classes, structs, interfaces) from source code.\n\nWHAT TO EXTRACT:\nType definitions that represent data structures, models, or contracts in the codebase.\n\nNAMING RULES (MANDATORY):\n1. Use the exact class/type name as defined in code\n2. Preserve original casing (PascalCase, snake_case as found)\n3. Include module prefix if needed for disambiguation\n\nSELECTION CRITERIA:\n- Include: Classes, dataclasses, TypedDict, NamedTuple, Protocols\n- Include: Database models, API schemas, domain entities\n- Exclude: Test fixtures, mock classes, abstract base classes without implementations\n\nLIMIT: Maximum 10 type definitions per file.\n\nOutput stable, deterministic results.",
    "example": "{\"types\": [{\"typeName\": \"UserRepository\", \"category\": \"class\", \"description\": \"Data access layer for User entities\", \"interfaceType\": \"repository\", \"startLine\": 15, \"endLine\": 45, \"confidence\": 0.95}]}",
    "is_active": true,
    "extraction_method": "llm",
    "temperature": 0.30000001192092896,
    "max_tokens": 4000,
    "created_at": "2026-01-10T20:55:22.358579"
  },
  {
    "id": 8,
    "node_type": "Method",
    "version": 1,
    "sequence": 8,
    "enabled": true,
    "input_sources": "{\"files\": [], \"nodes\": [{\"label\": \"TypeDefinition\", \"property\": \"codeSnippet\"}]}",
    "instruction": "Extract method/function definitions from source code.\n\nWHAT TO EXTRACT:\nFunctions and methods that represent callable units of behavior.\n\nNAMING RULES (MANDATORY):\n1. Use the exact function/method name as defined\n2. Include class prefix for methods: ClassName.method_name\n3. Preserve original naming convention\n\nSELECTION CRITERIA:\n- Include: Public methods, API endpoints, business logic functions\n- Include: Functions with multiple callers (high in_degree)\n- Exclude: Private methods (starting with _)\n- Exclude: Property getters/setters, dunder methods\n\nLIMIT: Maximum 15 methods per file.\n\nOutput stable, deterministic results.",
    "example": "{\"methodName\": \"authenticate\", \"returnType\": \"bool\", \"visibility\": \"public\", \"parameters\": \"self, username: str, password: str\", \"description\": \"Authenticates a user with credentials\", \"isStatic\": false, \"isAsync\": false, \"startLine\": 5, \"endLine\": 12, \"confidence\": 0.9}",
    "is_active": true,
    "extraction_method": "llm",
    "temperature": 0.30000001192092896,
    "max_tokens": 4000,
    "created_at": "2025-11-07T10:15:44.084119"
  },
  {
    "id": 9,
    "node_type": "Test",
    "version": 1,
    "sequence": 9,
    "enabled": false,
    "input_sources": "{\"files\": [{\"type\": \"test\", \"subtype\": \"*\"}], \"nodes\": []}",
    "instruction": "Extract test definitions from test files.\n\nFor each test, identify:\n- testName: Name of the test function/method\n- testType: One of [unit, integration, e2e, performance, smoke, regression, other]\n- description: Brief description of what the test verifies\n- testedElement: What is being tested (class name, function name, feature name)\n- framework: Test framework used (e.g., \"pytest\", \"unittest\", \"jest\", \"mocha\")\n- startLine: Line number where the test starts\n- endLine: Line number where the test ends\n- confidence: Your confidence in this extraction (0.0 to 1.0)\n\nIdentify the test type based on:\n- File location (e.g., tests/unit/, tests/integration/)\n- Test name patterns (test_unit_*, test_integration_*)\n- Test content and what it is testing (mocking = unit, real services = integration)\n\nIMPORTANT: Use the exact line numbers shown in the file content.",
    "example": "{\"testName\": \"test_user_authentication\", \"testType\": \"unit\", \"description\": \"Tests user login with valid credentials\", \"testedElement\": \"UserService.authenticate\", \"framework\": \"pytest\", \"startLine\": 10, \"endLine\": 25, \"confidence\": 0.9}",
    "is_active": true,
    "extraction_method": "llm",
    "temperature": 0.30000001192092896,
    "max_tokens": 8000,
    "created_at": "2025-11-07T10:15:44.086606"
  }
]