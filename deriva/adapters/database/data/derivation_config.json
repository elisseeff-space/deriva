[
  {
    "id": 1,
    "step_name": "degree_centrality",
    "phase": "prep",
    "version": 1,
    "sequence": 0,
    "enabled": true,
    "llm": false,
    "input_graph_query": null,
    "input_model_query": null,
    "instruction": null,
    "example": null,
    "params": "{}",
    "is_active": true,
    "max_candidates": 30,
    "batch_size": 10,
    "temperature": null,
    "max_tokens": null,
    "created_at": "2026-01-08T14:35:52.905424"
  },
  {
    "id": 2,
    "step_name": "ApplicationComponent",
    "phase": "generate",
    "version": 1,
    "sequence": 1,
    "enabled": true,
    "llm": true,
    "input_graph_query": "MATCH (n:`Graph:Directory`)\nWHERE n.active = true\n  AND NOT n.name IN ['__pycache__', 'node_modules', '.git', '.venv', 'venv', 'dist', 'build',\n                     'static', 'assets', 'public', 'images', 'img', 'css', 'js', 'fonts',\n                     'templates', 'views', 'layouts', 'partials']\n  AND NOT n.path =~ '.*(test|spec|__pycache__|node_modules|\\\\.git|\\\\.venv|venv|dist|build).*'\nRETURN n.id as id, n.name as name, labels(n) as labels, properties(n) as properties",
    "input_model_query": null,
    "instruction": "<persona>\nYou are a senior enterprise architect with 15+ years of ArchiMate 3.2 expertise. You value semantic precision and consistent terminology above all else. You identify application components based on their architectural role as deployable units.\n</persona>\n\n<definition>\nAn ApplicationComponent represents a modular, deployable part of a software system that encapsulates behavior and data. These are structural elements at the DIRECTORY level representing logical groupings of functionality.\n</definition>\n\n<semantic_exclusions>\nAn ApplicationComponent is NOT:\n- An ApplicationService (components realize services, they are not services)\n- A single file or class (too granular)\n- A utility function or helper (those belong to a component)\n- A configuration artifact (that's a DataObject)\n\nDO NOT:\n- Create components for individual modules within a directory\n- Create components for test directories\n- Create components that don't contain executable code\n- Create multiple components for the same functional area\n</semantic_exclusions>\n\n<granularity_constraint>\nDIRECTORY LEVEL ONLY: Model at the major directory level, not at module/package level.\n\nCORRECT: ac_backend for the entire backend/ directory\nINCORRECT: ac_backend_auth, ac_backend_users as separate components within backend/\n\nException: Only create sub-directory components when they represent genuinely independent deployable units.\n</granularity_constraint>\n\n<component_test>\nVALIDATION RULE (apply to every candidate):\nA candidate ApplicationComponent must answer \"What services does this component realize?\" with at least one ApplicationService.\n\nREJECT if:\n- No service can be associated with this component\n- The component only contains utilities with no service realization\n- The component is purely configuration or documentation\n</component_test>\n\n<realization_constraint>\nSTRICT REALIZATION: Every ApplicationComponent must realize at least one ApplicationService.\n\nComponents without service realization should be:\n- Merged into a parent component, OR\n- Reconsidered as part of another element type (DataObject for configs)\n</realization_constraint>\n\n<naming_rules>\nIDENTIFIER FORMAT (MANDATORY):\n- Prefix: ac_\n- Format: ac_<functional_area>\n- Style: lowercase snake_case\n- NEVER include repository name\n\nNORMALIZATION PRECEDENCE:\n1. Prefer canonical patterns over derived names\n2. Prefer broader functional names over specific technology names\n3. Prefer singular over plural\n4. Prefer architectural role over directory name\n\nCONFLICT RESOLUTION:\n- ac_server vs ac_backend → choose ac_backend (standard term)\n- ac_src vs ac_core → choose ac_core (meaningful)\n- ac_lib vs ac_common → choose ac_common (standard term)\n</naming_rules>\n\n<canonical_patterns>\n| Directory Pattern | Identifier | Name |\n|-------------------|------------|------|\n| backend/, server/, api/ | ac_backend | Backend |\n| frontend/, client/, ui/, web/ | ac_frontend | Frontend |\n| src/, app/, main/, core/ | ac_core | Core |\n| services/, handlers/ | ac_services | Services |\n| models/, entities/, domain/ | ac_models | Models |\n| utils/, lib/, common/, shared/ | ac_common | Common |\n| worker/, jobs/, tasks/ | ac_worker | Worker |\n| gateway/, proxy/ | ac_gateway | Gateway |\n\nFor directories not matching canonical patterns, derive identifier from functional purpose (kafka/ → ac_kafka).\n</canonical_patterns>\n\n<selection_criteria>\nINCLUDE directories that:\n- Represent cohesive deployable units\n- Have high pagerank (structurally important)\n- Contain multiple source files\n- Realize at least one ApplicationService\n\nEXCLUDE:\n- Build artifacts: dist/, build/, node_modules/, __pycache__/\n- Documentation: docs/, .github/\n- Configuration only: config/ (unless contains code)\n- Test directories: tests/, test/, spec/\n- Empty or trivial directories\n</selection_criteria>\n\n<granularity_rules>\nTARGET: 3-7 ApplicationComponents per repository\n\nESCALATION RULES:\n- If > 7 candidates: merge by functional area until <= 7\n- If < 3 candidates: verify this is correct (small repos may have fewer)\n- If directory has no realizable services: do not create component\n</granularity_rules>\n\n<determinism>\nORDERING: Sort elements alphabetically by identifier.\n\nCONFIDENCE BANDS (fixed):\n- 0.9-1.0: Canonical patterns with clear service realization\n- 0.8-0.89: Clear derived components with identifiable services\n- 0.7-0.79: Inferred components with uncertain service mapping\n\nCONSISTENCY:\n- Do not invent synonyms across runs\n- Use identical identifiers for identical directories\n- Given identical input, produce identical output\n</determinism>\n\n<output_format>\nJSON with \"elements\" array containing:\n- identifier: ac_ prefix + functional area (snake_case)\n- name: Title Case component name\n- documentation: One sentence describing what services this component realizes\n- source: Source directory node ID\n- confidence: Per confidence bands above\n</output_format>\n",
    "example": "{\n  \"elements\": [\n    {\n      \"identifier\": \"ac_backend\",\n      \"name\": \"Backend\",\n      \"documentation\": \"Server-side application containing API endpoints and business logic\",\n      \"source\": \"dir_backend\",\n      \"confidence\": 0.95\n    },\n    {\n      \"identifier\": \"ac_frontend\",\n      \"name\": \"Frontend\",\n      \"documentation\": \"Client-side web application with user interface components\",\n      \"source\": \"dir_frontend\",\n      \"confidence\": 0.9\n    },\n    {\n      \"identifier\": \"ac_core\",\n      \"name\": \"Core\",\n      \"documentation\": \"Core application logic and domain services\",\n      \"source\": \"dir_src\",\n      \"confidence\": 0.85\n    }\n  ]\n}",
    "params": "{\"temperature\": 0.0}",
    "is_active": true,
    "max_candidates": 30,
    "batch_size": 10,
    "temperature": null,
    "max_tokens": null,
    "created_at": "2026-01-14T21:51:54.562602"
  },
  {
    "id": 3,
    "step_name": "k_core_filter",
    "phase": "prep",
    "version": 1,
    "sequence": 1,
    "enabled": true,
    "llm": false,
    "input_graph_query": "MATCH (n:Graph) OPTIONAL MATCH (n)-[r]-() WITH n, count(r) as degree RETURN n, degree",
    "input_model_query": null,
    "instruction": null,
    "example": null,
    "params": "{\"k\": 2, \"description\": \"Remove nodes with degree < k\"}",
    "is_active": true,
    "max_candidates": 30,
    "batch_size": 10,
    "temperature": null,
    "max_tokens": null,
    "created_at": "2026-01-02T12:41:14.069926"
  },
  {
    "id": 4,
    "step_name": "Completeness",
    "phase": "refine",
    "version": 1,
    "sequence": 1,
    "enabled": false,
    "llm": true,
    "input_graph_query": "MATCH (n:Graph) WHERE n.significance > 0.5 AND n.active = true RETURN n",
    "input_model_query": "MATCH (e:Model) RETURN e",
    "instruction": "Compare graph nodes with ArchiMate elements. Identify graph nodes with high significance (>0.5) that don't have corresponding ArchiMate elements. For each missing element, suggest creating an appropriate ArchiMate element with proper type, name, and relationships. Return an array of new elements to add with their confidence scores.",
    "example": "{\"new_elements\":[{\"identifier\":\"ac:payment-processor\",\"type\":\"ApplicationComponent\",\"name\":\"Payment Processor\",\"source_node\":\"Graph:PaymentService\",\"reason\":\"High-significance service node without ArchiMate representation\",\"confidence\":0.85}],\"new_relationships\":[]}",
    "params": null,
    "is_active": true,
    "max_candidates": 30,
    "batch_size": 10,
    "temperature": null,
    "max_tokens": null,
    "created_at": "2026-01-02T12:41:14.123083"
  },
  {
    "id": 5,
    "step_name": "duplicate_elements",
    "phase": "refine",
    "version": 1,
    "sequence": 1,
    "enabled": true,
    "llm": true,
    "input_graph_query": null,
    "input_model_query": null,
    "instruction": "Find and handle duplicate ArchiMate elements: Tier 1 (exact name+type) auto-merge, Tier 2 (fuzzy match) flag, Tier 3 (semantic via LLM) merge only with >0.95 confidence.",
    "example": null,
    "params": "{\"use_lemmatization\": true, \"auto_merge_tier2\": true}",
    "is_active": true,
    "max_candidates": 30,
    "batch_size": 10,
    "temperature": null,
    "max_tokens": null,
    "created_at": "2026-01-10T07:35:10.290625"
  },
  {
    "id": 6,
    "step_name": "ApplicationService",
    "phase": "generate",
    "version": 1,
    "sequence": 2,
    "enabled": true,
    "llm": true,
    "input_graph_query": "MATCH (n:`Graph:Method`)\nWHERE n.active = true\nRETURN n.id as id,\n       COALESCE(n.name, n.methodName) as name,\n       labels(n) as labels,\n       properties(n) as properties",
    "input_model_query": null,
    "instruction": "<persona>\nYou are a senior enterprise architect with 15+ years of ArchiMate 3.2 expertise. You value semantic precision and consistent terminology above all else. You identify application services based on business capabilities, not code structure.\n</persona>\n\n<definition>\nAn ApplicationService represents a coherent piece of functionality that fulfills a specific business need. Services expose behavior through interfaces and are realized by application components.\n</definition>\n\n<semantic_exclusions>\nAn ApplicationService is NOT:\n- An ApplicationFunction (internal behavior, not exposed)\n- An ApplicationProcess (sequence of activities, not a capability)\n- A technical API endpoint (unless it represents a business-facing capability)\n- A CRUD operation (create/read/update/delete is not a service)\n- An infrastructure service (caching, logging, database access)\n\nDO NOT:\n- Create multiple ApplicationServices for the same capability exposed via different protocols\n- Model internal utility functions as services\n- Create services for framework lifecycle methods\n- Model technical cross-cutting concerns (caching, logging, metrics) as services\n- Create fine-grained services when a broader capability applies\n</semantic_exclusions>\n\n<scope_constraint>\nBUSINESS-FACING ONLY: Only model services that provide business value to external consumers.\n\nDO NOT model as ApplicationService:\n- Caching services\n- Logging services\n- Database access layers\n- Message queue handlers (unless business-facing)\n- Health check endpoints\n</scope_constraint>\n\n<capability_test>\nVALIDATION RULE (apply to every candidate):\nA candidate ApplicationService must answer \"What business outcome does this enable?\" in one sentence WITHOUT referring to technical mechanisms.\n\nREJECT or MERGE if the description:\n- Starts with \"manages\", \"handles\", or \"provides access to\" without a business outcome\n- Describes technical implementation rather than business value\n- Cannot be explained to a business stakeholder\n- Is a sub-capability of a broader service (merge into parent)\n\nExample VALID: \"Enables customers to place and track orders\"\nExample INVALID: \"Handles HTTP requests for user data\"\nExample MERGE: \"Generates invoices\" → merge into as_order_management\n</capability_test>\n\n<broad_capability_rule>\nPREFER BROADER CAPABILITIES: When in doubt, merge into a broader service.\n\nMERGE EXAMPLES:\n- Invoice generation → as_order_management\n- Email sending → as_notification\n- Profile updates → as_user_management\n- Password reset → as_authentication\n\nOnly create a separate service when:\n- It serves a different business domain\n- It has distinct consumers\n- It represents a standalone product capability\n</broad_capability_rule>\n\n<naming_rules>\nIDENTIFIER FORMAT (MANDATORY):\n- Prefix: as_\n- Format: as_<capability_noun>\n- Style: lowercase snake_case\n- NEVER include repository name\n\nNORMALIZATION PRECEDENCE (apply in order):\n1. Prefer canonical patterns over derived names\n2. Prefer broader capability names over sub-capabilities\n3. Prefer nouns over verbs in identifiers\n4. Prefer industry-standard terms when available\n\nCONFLICT RESOLUTION:\n- as_user_profile vs as_user_management → choose as_user_management (broader)\n- as_send_email vs as_notification → choose as_notification (standard term)\n- as_auth vs as_authentication → choose as_authentication (explicit)\n- as_invoice_generation vs as_order_management → choose as_order_management (broader)\n</naming_rules>\n\n<canonical_patterns>\n| Capability | Identifier | Name |\n|------------|------------|------|\n| Login, sessions, tokens, password reset | as_authentication | Authentication Service |\n| User CRUD, profiles, accounts, preferences | as_user_management | User Management Service |\n| Payment processing, billing, refunds | as_payment | Payment Service |\n| Order lifecycle, checkout, invoicing | as_order_management | Order Management Service |\n| Email, SMS, push notifications | as_notification | Notification Service |\n| Search, indexing, queries | as_search | Search Service |\n| File upload, storage, retrieval | as_file_management | File Management Service |\n| Reports, analytics, dashboards, exports | as_reporting | Reporting Service |\n| Core domain data operations | as_data_management | Data Management Service |\n| Scheduling, jobs, workflows | as_scheduling | Scheduling Service |\n</canonical_patterns>\n\n<selection_criteria>\nINCLUDE services that:\n- Provide distinct business capabilities\n- Can be explained without technical jargon\n- Are reusable across multiple consumers\n- Have clear input/output contracts\n- Serve external business needs\n\nEXCLUDE:\n- Internal utilities and helpers\n- Framework-specific handlers\n- Configuration loaders\n- Test utilities\n- Infrastructure services (caching, logging, metrics)\n</selection_criteria>\n\n<granularity_rules>\nTARGET: 3-8 ApplicationServices per repository\n\nESCALATION RULES:\n- If > 8 candidates: merge into broader capabilities until <= 8\n- If < 3 candidates: reassess for missing cross-cutting capabilities:\n  - Authentication (if login/security code exists)\n  - Notification (if email/messaging code exists)\n  - Reporting (if analytics/export code exists)\n</granularity_rules>\n\n<realization_constraint>\nEach ApplicationService must be realizable by at least one ApplicationComponent inferred from the repository.\n\nIf no plausible realizing component exists, do not create the service.\n</realization_constraint>\n\n<determinism>\nORDERING: Sort elements alphabetically by identifier.\n\nCONFIDENCE BANDS (fixed):\n- 0.9-1.0: Canonical patterns with clear code evidence\n- 0.8-0.89: Clear derived capabilities with strong signals\n- 0.7-0.79: Inferred or ambiguous cases\n\nCONSISTENCY:\n- Do not invent synonyms across runs\n- Use identical identifiers for identical capabilities\n- Given identical input, produce identical output\n</determinism>\n\n<output_format>\nJSON with \"elements\" array containing:\n- identifier: as_ prefix + capability noun (snake_case)\n- name: Title Case service name\n- documentation: One sentence describing business outcome (not technical implementation)\n- source: Source node ID\n- confidence: Per confidence bands above\n</output_format>\n",
    "example": "{\n  \"elements\": [\n    {\n      \"identifier\": \"as_manage_entity\",\n      \"name\": \"Entity Management Service\",\n      \"documentation\": \"CRUD operations on business entities - creating, reading, updating, and deleting business data\",\n      \"source\": \"method_create_item\",\n      \"confidence\": 0.9\n    },\n    {\n      \"identifier\": \"as_authenticate_user\",\n      \"name\": \"User Authentication Service\",\n      \"documentation\": \"Handles user login, logout, and session management\",\n      \"source\": \"method_login\",\n      \"confidence\": 0.85\n    }\n  ]\n}",
    "params": "{\"temperature\": 0.0}",
    "is_active": true,
    "max_candidates": 30,
    "batch_size": 10,
    "temperature": null,
    "max_tokens": null,
    "created_at": "2026-01-14T21:53:30.297336"
  },
  {
    "id": 7,
    "step_name": "scc_detection",
    "phase": "prep",
    "version": 1,
    "sequence": 2,
    "enabled": false,
    "llm": false,
    "input_graph_query": "MATCH (n:Graph)-[r]->(m:Graph) RETURN n, r, m",
    "input_model_query": null,
    "instruction": null,
    "example": null,
    "params": "{\"min_size\": 2, \"description\": \"Detect strongly connected components\"}",
    "is_active": true,
    "max_candidates": 30,
    "batch_size": 10,
    "temperature": null,
    "max_tokens": null,
    "created_at": "2026-01-02T12:41:14.076560"
  },
  {
    "id": 8,
    "step_name": "RelationshipConsistency",
    "phase": "refine",
    "version": 1,
    "sequence": 2,
    "enabled": false,
    "llm": true,
    "input_graph_query": "MATCH (source:Graph)-[r]->(target:Graph) WHERE source.significance > 0.3 AND target.significance > 0.3 AND source.active = true AND target.active = true RETURN source, type(r) as rel_type, target",
    "input_model_query": "MATCH (source:Model)-[r]->(target:Model) RETURN source, type(r) as rel_type, target",
    "instruction": "Compare relationships between graph nodes and ArchiMate elements. Identify missing or incorrect relationships in the ArchiMate model. For each discrepancy, suggest adding or updating relationships using appropriate ArchiMate relationship types (Composition, Aggregation, Serving, Realization, Access, Flow). Ensure relationship types follow ArchiMate metamodel rules. Return arrays of new and updated relationships.",
    "example": "{\"new_elements\":[],\"new_relationships\":[{\"source\":\"ac:api-gateway\",\"target\":\"as:user-service\",\"type\":\"Serving\",\"reason\":\"Graph shows API Gateway calls User Service, missing in ArchiMate\",\"confidence\":0.9}],\"updated_relationships\":[{\"source\":\"ac:database\",\"target\":\"do:user-data\",\"old_type\":\"Composition\",\"new_type\":\"Access\",\"reason\":\"Database accesses data, not composes it\",\"confidence\":0.85}]}",
    "params": null,
    "is_active": true,
    "max_candidates": 30,
    "batch_size": 10,
    "temperature": null,
    "max_tokens": null,
    "created_at": "2026-01-02T12:41:14.125716"
  },
  {
    "id": 9,
    "step_name": "orphan_elements",
    "phase": "refine",
    "version": 1,
    "sequence": 2,
    "enabled": true,
    "llm": false,
    "input_graph_query": null,
    "input_model_query": null,
    "instruction": "Find ArchiMate elements with no relationships. Flag them for review or propose relationships based on source graph patterns.",
    "example": null,
    "params": "{\"disable_orphans\": false, \"min_importance\": 0}",
    "is_active": true,
    "max_candidates": null,
    "batch_size": null,
    "temperature": null,
    "max_tokens": null,
    "created_at": "2026-01-09T00:00:00"
  },
  {
    "id": 10,
    "step_name": "ApplicationInterface",
    "phase": "generate",
    "version": 1,
    "sequence": 3,
    "enabled": true,
    "llm": true,
    "input_graph_query": "MATCH (f:`Graph:File`) WHERE f.active = true AND f.fileType = \"source\" AND (f.fileName CONTAINS \"route\" OR f.fileName CONTAINS \"api\" OR f.fileName CONTAINS \"endpoint\" OR f.fileName CONTAINS \"controller\") RETURN f.id as id, f.fileName as name, f.filePath as path",
    "input_model_query": null,
    "instruction": "<persona>\nYou are a senior enterprise architect with 15+ years of ArchiMate 3.2 expertise. You value semantic precision and consistent terminology above all else. You identify application interfaces based on their exposed contract, not implementation details.\n</persona>\n\n<definition>\nAn ApplicationInterface represents a point of access where application services are made available to external consumers. These are the inbound contracts through which the system exposes capabilities.\n</definition>\n\n<semantic_exclusions>\nAn ApplicationInterface is NOT:\n- An outbound integration (external APIs the system consumes)\n- An internal method signature (not exposed externally)\n- A data model or schema (that's a DataObject)\n- A service implementation (that's an ApplicationService)\n\nDO NOT:\n- Create separate interfaces for each protocol exposing the same capability\n- Model internal function calls as interfaces\n- Create interfaces for framework-generated endpoints (health checks, metrics)\n</semantic_exclusions>\n\n<scope_constraint>\nINBOUND ONLY: Only model interfaces that THIS system exposes to external consumers.\n\nDO NOT model:\n- External APIs the system calls (those belong to external systems)\n- Third-party service integrations\n- Database connections (those are technology-level)\n</scope_constraint>\n\n<protocol_merging>\nSINGLE INTERFACE PER CAPABILITY: When the same capability is exposed via multiple protocols (REST + GraphQL, HTTP + gRPC), create ONE ApplicationInterface element.\n\nExample:\n- REST /api/users AND GraphQL users query → ONE ai_user_api\n- Document all protocols in the description field\n</protocol_merging>\n\n<interface_test>\nVALIDATION RULE (apply to every candidate):\nA candidate ApplicationInterface must answer \"What external consumer uses this to access what capability?\" in one sentence.\n\nREJECT if:\n- No external consumer can be identified\n- The interface is purely internal\n- It duplicates another interface's capability\n</interface_test>\n\n<naming_rules>\nIDENTIFIER FORMAT (MANDATORY):\n- Prefix: ai_\n- Format: ai_<interface_description>\n- Style: lowercase snake_case\n- NEVER include repository name or protocol in identifier\n\nNORMALIZATION PRECEDENCE:\n1. Prefer canonical patterns over derived names\n2. Prefer capability-based names over protocol-based names\n3. Prefer singular over plural\n4. Prefer industry-standard terms when available\n\nCONFLICT RESOLUTION:\n- ai_rest_api vs ai_api → choose ai_api (protocol-agnostic)\n- ai_users_endpoint vs ai_user_api → choose ai_user_api (standard)\n</naming_rules>\n\n<canonical_patterns>\n| Interface Type | Identifier | Name |\n|----------------|------------|------|\n| Primary system API | ai_api | System API |\n| User-related endpoints | ai_user_api | User API |\n| Authentication endpoints | ai_auth_api | Authentication API |\n| Admin/management endpoints | ai_admin_api | Admin API |\n| Public/external API | ai_public_api | Public API |\n| WebSocket/realtime | ai_realtime | Realtime Interface |\n| CLI commands | ai_cli | CLI Interface |\n| Message queue consumer | ai_message_consumer | Message Consumer Interface |\n| File import interface | ai_file_import | File Import Interface |\n</canonical_patterns>\n\n<selection_criteria>\nINCLUDE interfaces that:\n- Expose functionality to external consumers\n- Have defined contracts (OpenAPI, GraphQL schema, etc.)\n- Represent system boundaries\n- Are documented or self-describing\n\nEXCLUDE:\n- Internal method calls\n- Private utility functions\n- Framework-generated endpoints (health, metrics)\n- Test endpoints\n</selection_criteria>\n\n<granularity_rules>\nTARGET: 2-5 ApplicationInterfaces per repository\n\nESCALATION RULES:\n- If > 5 candidates: merge by capability until <= 5\n- If < 2 candidates: verify system has no external API (some libs/tools don't)\n- If 0 candidates: this may be correct for libraries with no exposed API\n</granularity_rules>\n\n<realization_constraint>\nEach ApplicationInterface must be associated with at least one ApplicationService that provides the capability.\n\nIf no underlying service exists, do not create the interface.\n</realization_constraint>\n\n<determinism>\nORDERING: Sort elements alphabetically by identifier.\n\nCONFIDENCE BANDS (fixed):\n- 0.9-1.0: Canonical patterns with clear code evidence (routes, controllers)\n- 0.8-0.89: Clear derived interfaces with API definitions\n- 0.7-0.79: Inferred interfaces from code structure\n\nCONSISTENCY:\n- Do not invent synonyms across runs\n- Use identical identifiers for identical interfaces\n- Given identical input, produce identical output\n</determinism>\n\n<output_format>\nJSON with \"elements\" array containing:\n- identifier: ai_ prefix + interface description (snake_case)\n- name: Title Case interface name\n- documentation: One sentence describing what external consumers access and how\n- source: Source node ID\n- confidence: Per confidence bands above\n</output_format>\n",
    "example": "{\n  \"elements\": [\n    {\n      \"identifier\": \"ai_rest_api\",\n      \"name\": \"REST API\",\n      \"documentation\": \"HTTP REST interface exposing application services to external clients\",\n      \"source\": \"file_api_routes\",\n      \"confidence\": 0.95\n    },\n    {\n      \"identifier\": \"ai_web_forms\",\n      \"name\": \"Web Forms Interface\",\n      \"documentation\": \"HTML form-based interface for user input and data submission\",\n      \"source\": \"file_forms\",\n      \"confidence\": 0.9\n    }\n  ]\n}\n",
    "params": "{\"temperature\": 0.0}",
    "is_active": true,
    "max_candidates": 30,
    "batch_size": 10,
    "temperature": null,
    "max_tokens": null,
    "created_at": "2026-01-14T21:53:46.167133"
  },
  {
    "id": 11,
    "step_name": "louvain_communities",
    "phase": "prep",
    "version": 1,
    "sequence": 3,
    "enabled": true,
    "llm": false,
    "input_graph_query": "MATCH (n:Graph)-[r]->(m:Graph) RETURN n, r, m",
    "input_model_query": null,
    "instruction": null,
    "example": null,
    "params": "{\"resolution\": 1.0, \"description\": \"Detect communities using Louvain algorithm\"}",
    "is_active": true,
    "max_candidates": 30,
    "batch_size": 10,
    "temperature": null,
    "max_tokens": null,
    "created_at": "2026-01-02T12:41:14.079345"
  },
  {
    "id": 12,
    "step_name": "LayeringAbstraction",
    "phase": "refine",
    "version": 1,
    "sequence": 3,
    "enabled": false,
    "llm": true,
    "input_graph_query": "MATCH (n:Graph) WHERE n.active = true RETURN n, labels(n) as node_labels, n.category as category",
    "input_model_query": "MATCH (e:Model) RETURN e, e.type as element_type, e.layer as layer",
    "instruction": "Analyze the ArchiMate model for proper layering and abstraction. Check: 1) Elements are in correct layers (Business/Application/Technology), 2) Abstraction levels are appropriate (not too technical in business layer, not too abstract in technology layer), 3) Cross-layer relationships follow ArchiMate patterns. Suggest reclassifying elements or splitting/merging elements to improve architectural clarity. Return arrays of reclassified elements, split suggestions, and new relationships.",
    "example": "{\"reclassified_elements\":[{\"identifier\":\"ac:user-authentication\",\"current_type\":\"ApplicationComponent\",\"suggested_type\":\"ApplicationService\",\"reason\":\"Represents behavior/capability, not a structural component\",\"confidence\":0.8}],\"split_suggestions\":[{\"identifier\":\"ac:monolith-app\",\"suggested_elements\":[{\"type\":\"ApplicationComponent\",\"name\":\"User Management Module\"},{\"type\":\"ApplicationComponent\",\"name\":\"Order Processing Module\"},{\"type\":\"ApplicationComponent\",\"name\":\"Inventory Module\"}],\"reason\":\"Large monolithic component should be decomposed for clarity\",\"confidence\":0.7}],\"new_relationships\":[]}",
    "params": null,
    "is_active": true,
    "max_candidates": 30,
    "batch_size": 10,
    "temperature": null,
    "max_tokens": null,
    "created_at": "2026-01-02T12:41:14.128141"
  },
  {
    "id": 13,
    "step_name": "duplicate_relationships",
    "phase": "refine",
    "version": 1,
    "sequence": 3,
    "enabled": true,
    "llm": false,
    "input_graph_query": null,
    "input_model_query": null,
    "instruction": "Find and remove duplicate relationships (same source, target, type). Also check for redundant relationship pairs.",
    "example": null,
    "params": "{\"check_redundant\": true}",
    "is_active": true,
    "max_candidates": null,
    "batch_size": null,
    "temperature": null,
    "max_tokens": null,
    "created_at": "2026-01-09T00:00:00"
  },
  {
    "id": 14,
    "step_name": "DataObject",
    "phase": "generate",
    "version": 1,
    "sequence": 4,
    "enabled": true,
    "llm": true,
    "input_graph_query": "MATCH (n:`Graph:File`)\nWHERE n.active = true\nRETURN n.id as id,\n       COALESCE(n.fileName, n.name) as name,\n       labels(n) as labels,\n       properties(n) as properties",
    "input_model_query": null,
    "instruction": "<persona>\nYou are a senior enterprise architect with 15+ years of ArchiMate 3.2 expertise. You value semantic precision and consistent terminology above all else. You identify data objects based on their content purpose and domain significance.\n</persona>\n\n<definition>\nA DataObject represents data structured for automated processing. These are the technical artifacts that store persistent data - databases, configuration files, schemas, data files.\n</definition>\n\n<semantic_exclusions>\nA DataObject is NOT:\n- A BusinessObject (business concept, not technical storage)\n- A runtime cache or session store\n- A message queue or stream\n- Source code or executable files\n\nDO NOT:\n- Model Redis/Memcached caches as DataObjects\n- Model message queues (Kafka topics, RabbitMQ queues)\n- Model session stores\n- Model source code files (*.py, *.js)\n</semantic_exclusions>\n\n<scope_constraint>\nFILE-BASED ARTIFACTS ONLY: Only model files and file-like persistent stores.\n\nVALID (file-based):\n- Databases (*.db, *.sqlite)\n- Configuration files (*.json, *.yaml, *.env)\n- Schema definitions\n- Data files (*.csv, *.xml)\n- Build definitions (Dockerfile, Makefile)\n\nINVALID (runtime):\n- Redis cache\n- Message queues\n- Session stores\n- In-memory caches\n</scope_constraint>\n\n<naming_constraint>\nDOMAIN-DERIVED NAMES: Name based on content purpose, not just file type.\n\nVALID (purpose-based):\n- do_user_schema (schema defining user structure)\n- do_order_config (configuration for order processing)\n- do_invoice_data (data file containing invoices)\n\nAVOID (generic):\n- do_json_file (too generic)\n- do_config (which config?)\n- do_data (which data?)\n\nException: For standard infrastructure files, use standard names:\n- do_requirements, do_dockerfile, do_makefile\n</naming_constraint>\n\n<object_test>\nVALIDATION RULE (apply to every candidate):\nA candidate DataObject must answer \"What data does this store and for what purpose?\" in one sentence.\n\nREJECT if:\n- Purpose cannot be articulated\n- It's source code, not data\n- It's a runtime/ephemeral store\n</object_test>\n\n<naming_rules>\nIDENTIFIER FORMAT (MANDATORY):\n- Prefix: do_\n- Format: do_<purpose>_<type> or do_<standard_name>\n- Style: lowercase snake_case\n\nNORMALIZATION PRECEDENCE:\n1. Prefer purpose-based names over file-type names\n2. Prefer standard names for infrastructure files\n3. Prefer singular over plural\n4. Prefer specific over generic\n\nCONFLICT RESOLUTION:\n- do_config vs do_app_config → choose do_app_config (specific)\n- do_database vs do_order_database → choose do_order_database (purpose)\n- do_yml vs do_deployment_config → choose do_deployment_config (purpose)\n</naming_rules>\n\n<canonical_infrastructure>\nUse these standard identifiers for common infrastructure files:\n\n| File Pattern | Identifier | Name |\n|--------------|------------|------|\n| requirements*.txt, Pipfile | do_python_requirements | Python Requirements |\n| package.json | do_node_packages | Node Package Config |\n| Dockerfile, docker-compose* | do_docker_config | Docker Configuration |\n| Makefile | do_makefile | Build Makefile |\n| *.env, .env* | do_environment | Environment Variables |\n| *.db, *.sqlite | do_<purpose>_database | <Purpose> Database |\n</canonical_infrastructure>\n\n<selection_criteria>\nINCLUDE data objects that:\n- Store persistent data\n- Define schemas or structures\n- Configure application behavior\n- Contain significant data files\n\nEXCLUDE:\n- Source code files (*.py, *.js, *.go)\n- Test fixtures (unless significant)\n- Documentation files\n- Temporary files\n- Runtime caches\n</selection_criteria>\n\n<granularity_rules>\nTARGET: 3-8 DataObjects per repository\n\nESCALATION RULES:\n- If > 8 candidates: keep most significant data artifacts\n- If < 3 candidates: verify data files exist (pure logic libs may have few)\n- If 0 candidates: acceptable for stateless utility libraries\n</granularity_rules>\n\n<determinism>\nORDERING: Sort elements alphabetically by identifier.\n\nCONFIDENCE BANDS (fixed):\n- 0.9-1.0: Explicit data files with clear purpose\n- 0.8-0.89: Inferred data artifacts from usage patterns\n- 0.7-0.79: Configuration files with uncertain scope\n\nCONSISTENCY:\n- Do not invent synonyms across runs\n- Use identical identifiers for identical files\n- Given identical input, produce identical output\n</determinism>\n\n<output_format>\nJSON with \"elements\" array containing:\n- identifier: do_ prefix + purpose-based name (snake_case)\n- name: Title Case data object name\n- documentation: One sentence describing data content and purpose\n- source: Source file node ID\n- confidence: Per confidence bands above\n</output_format>\n",
    "example": "{\n  \"elements\": [\n    {\n      \"identifier\": \"do_application_database\",\n      \"name\": \"Application Database\",\n      \"documentation\": \"SQLite database storing application data\",\n      \"source\": \"file_database.db\",\n      \"confidence\": 0.95\n    },\n    {\n      \"identifier\": \"do_environment_configuration\",\n      \"name\": \"Environment Configuration\",\n      \"documentation\": \"Environment variables for application settings\",\n      \"source\": \"file_.flaskenv\",\n      \"confidence\": 0.9\n    }\n  ]\n}\n",
    "params": "{\"temperature\": 0.0}",
    "is_active": true,
    "max_candidates": 30,
    "batch_size": 10,
    "temperature": null,
    "max_tokens": null,
    "created_at": "2026-01-14T22:08:57.144509"
  },
  {
    "id": 15,
    "step_name": "articulation_points",
    "phase": "prep",
    "version": 1,
    "sequence": 4,
    "enabled": true,
    "llm": false,
    "input_graph_query": "MATCH (n:Graph)-[r]-(m:Graph) RETURN n, r, m",
    "input_model_query": null,
    "instruction": null,
    "example": null,
    "params": "{\"mark_critical\": true, \"description\": \"Identify articulation points (bridge nodes)\"}",
    "is_active": true,
    "max_candidates": 30,
    "batch_size": 10,
    "temperature": null,
    "max_tokens": null,
    "created_at": "2026-01-02T12:41:14.082007"
  },
  {
    "id": 16,
    "step_name": "graph_relationships",
    "phase": "refine",
    "version": 1,
    "sequence": 4,
    "enabled": true,
    "llm": false,
    "input_graph_query": null,
    "input_model_query": null,
    "instruction": null,
    "example": null,
    "params": "{\"edge_types\": [\"CONTAINS\", \"DECLARES\", \"IMPLEMENTS\", \"USES\", \"CALLS\", \"IMPORTS\"]}",
    "is_active": true,
    "max_candidates": 500,
    "batch_size": 50,
    "temperature": null,
    "max_tokens": null,
    "created_at": "2026-01-12T10:08:50.416642"
  },
  {
    "id": 17,
    "step_name": "BusinessProcess",
    "phase": "generate",
    "version": 1,
    "sequence": 5,
    "enabled": true,
    "llm": true,
    "input_graph_query": "MATCH (n:`Graph:Method`)\nWHERE n.active = true\nRETURN n.id as id,\n       COALESCE(n.name, n.methodName) as name,\n       labels(n) as labels,\n       properties(n) as properties",
    "input_model_query": null,
    "instruction": "<persona>\nYou are a senior enterprise architect with 15+ years of ArchiMate 3.2 expertise. You value semantic precision and consistent terminology above all else. You identify business processes based on business value, at whatever granularity they exist in the code.\n</persona>\n\n<definition>\nA BusinessProcess represents a sequence of business behaviors that achieves a specific outcome. Processes transform inputs into outputs and produce value for stakeholders.\n</definition>\n\n<semantic_exclusions>\nA BusinessProcess is NOT:\n- A technical workflow (CI/CD, deployment, build)\n- A framework lifecycle method\n- An internal utility function\n- A single CRUD operation without business context\n\nDO NOT:\n- Model CI/CD pipelines as business processes\n- Model deployment workflows\n- Model database migrations\n- Model technical maintenance tasks\n</semantic_exclusions>\n\n<scope_constraint>\nBUSINESS WORKFLOWS ONLY: Only model processes with business value.\n\nVALID (business value):\n- bp_process_order, bp_validate_payment, bp_generate_invoice\n- bp_register_customer, bp_approve_refund, bp_calculate_pricing\n\nINVALID (technical):\n- bp_deploy_application, bp_run_tests, bp_backup_database\n- bp_migrate_schema, bp_clear_cache, bp_rotate_logs\n</scope_constraint>\n\n<granularity_constraint>\nALL IDENTIFIABLE STEPS: Model business steps at whatever granularity they exist in the code.\n\nInclude:\n- End-to-end flows (bp_process_order)\n- Major steps (bp_validate_order)\n- Individual activities (bp_calculate_total)\n\nAs long as they have business meaning and can be identified in code.\n</granularity_constraint>\n\n<process_test>\nVALIDATION RULE (apply to every candidate):\nA candidate BusinessProcess must answer \"What business outcome does this produce?\" in one sentence.\n\nREJECT if:\n- The outcome is purely technical\n- No business value can be articulated\n- It's a framework or infrastructure concern\n</process_test>\n\n<naming_rules>\nIDENTIFIER FORMAT (MANDATORY):\n- Prefix: bp_\n- Format: bp_<verb>_<object>\n- Style: lowercase snake_case\n- Use imperative verb phrases\n\nNORMALIZATION PRECEDENCE:\n1. Prefer canonical patterns over derived names\n2. Prefer imperative verbs (process, validate, create)\n3. Prefer specific actions over generic (validate_order not check_order)\n4. Prefer business terminology\n\nCONFLICT RESOLUTION:\n- bp_order_processing vs bp_process_order → choose bp_process_order (imperative)\n- bp_do_payment vs bp_process_payment → choose bp_process_payment (standard)\n- bp_handle_customer vs bp_register_customer → choose bp_register_customer (specific)\n</naming_rules>\n\n<canonical_patterns>\n| Process Type | Identifier Pattern | Examples |\n|--------------|-------------------|----------|\n| Creation | bp_create_<entity> | bp_create_order, bp_create_account |\n| Processing | bp_process_<entity> | bp_process_payment, bp_process_claim |\n| Validation | bp_validate_<entity> | bp_validate_order, bp_validate_payment |\n| Approval | bp_approve_<entity> | bp_approve_request, bp_approve_refund |\n| Registration | bp_register_<entity> | bp_register_customer, bp_register_device |\n| Generation | bp_generate_<output> | bp_generate_report, bp_generate_invoice |\n| Calculation | bp_calculate_<value> | bp_calculate_total, bp_calculate_tax |\n| Notification | bp_notify_<recipient> | bp_notify_customer, bp_notify_admin |\n| Fulfillment | bp_fulfill_<entity> | bp_fulfill_order, bp_ship_order |\n</canonical_patterns>\n\n<selection_criteria>\nINCLUDE processes that:\n- Produce business outcomes\n- Transform business objects\n- Can be triggered by events or actors\n- Have identifiable steps in code\n\nEXCLUDE:\n- Technical workflows (CI/CD, deployment)\n- Framework lifecycle methods\n- Pure CRUD without business context\n- Internal utility operations\n</selection_criteria>\n\n<granularity_rules>\nTARGET: 4-12 BusinessProcesses per repository\n\nESCALATION RULES:\n- If > 12 candidates: keep the most significant, document others\n- If < 4 candidates: verify business logic exists\n- If 0 candidates: acceptable for pure infrastructure repositories\n</granularity_rules>\n\n<event_linkage>\nProcesses should either:\n- Be triggered by a BusinessEvent, OR\n- Produce a BusinessEvent\n\nIf neither applies, verify the process has business significance.\n</event_linkage>\n\n<determinism>\nORDERING: Sort elements alphabetically by identifier.\n\nCONFIDENCE BANDS (fixed):\n- 0.9-1.0: Explicit process/workflow classes or methods\n- 0.8-0.89: Inferred from service method patterns\n- 0.7-0.79: Identified from control flow analysis\n\nCONSISTENCY:\n- Do not invent synonyms across runs\n- Use identical identifiers for identical processes\n- Given identical input, produce identical output\n</determinism>\n\n<output_format>\nJSON with \"elements\" array containing:\n- identifier: bp_ prefix + verb + object (snake_case)\n- name: Title Case process name\n- documentation: One sentence describing business outcome\n- source: Source node ID\n- confidence: Per confidence bands above\n</output_format>\n",
    "example": "{\n  \"elements\": [\n    {\n      \"identifier\": \"bp_create_entity\",\n      \"name\": \"Create Entity\",\n      \"documentation\": \"Business process for creating new business entities\",\n      \"source\": \"method_create_record\",\n      \"confidence\": 0.9\n    },\n    {\n      \"identifier\": \"bp_update_entity\",\n      \"name\": \"Update Entity\",\n      \"documentation\": \"Business process for modifying existing entities\",\n      \"source\": \"method_update_record\",\n      \"confidence\": 0.85\n    },\n    {\n      \"identifier\": \"bp_generate_output\",\n      \"name\": \"Generate Output\",\n      \"documentation\": \"Business process for generating documents and reports\",\n      \"source\": \"method_render_report\",\n      \"confidence\": 0.85\n    }\n  ]\n}\n",
    "params": "{\"temperature\": 0.0}",
    "is_active": true,
    "max_candidates": 30,
    "batch_size": 10,
    "temperature": null,
    "max_tokens": null,
    "created_at": "2026-01-14T22:06:33.292159"
  },
  {
    "id": 18,
    "step_name": "pagerank",
    "phase": "prep",
    "version": 1,
    "sequence": 5,
    "enabled": true,
    "llm": false,
    "input_graph_query": "MATCH (n:Graph)-[r]->(m:Graph) RETURN n, r, m",
    "input_model_query": null,
    "instruction": null,
    "example": null,
    "params": "{\"damping\": 0.85, \"max_iter\": 100}",
    "is_active": true,
    "max_candidates": 30,
    "batch_size": 10,
    "temperature": null,
    "max_tokens": null,
    "created_at": "2026-01-02T12:41:14.084237"
  },
  {
    "id": 19,
    "step_name": "cross_layer_coherence",
    "phase": "refine",
    "version": 1,
    "sequence": 5,
    "enabled": true,
    "llm": false,
    "input_graph_query": null,
    "input_model_query": null,
    "instruction": "Validate ArchiMate cross-layer relationships: Business->Application->Technology. Flag elements without cross-layer connections.",
    "example": null,
    "params": "{\"check_business_to_app\": true, \"check_app_to_tech\": true}",
    "is_active": true,
    "max_candidates": null,
    "batch_size": null,
    "temperature": null,
    "max_tokens": null,
    "created_at": "2026-01-09T00:00:00"
  },
  {
    "id": 20,
    "step_name": "BusinessObject",
    "phase": "generate",
    "version": 1,
    "sequence": 6,
    "enabled": true,
    "llm": true,
    "input_graph_query": "MATCH (n)\nWHERE (n:`Graph:TypeDefinition` OR n:`Graph:BusinessConcept`)\n  AND n.active = true\nRETURN n.id as id,\n       COALESCE(n.name, n.typeName, n.conceptName) as name,\n       labels(n) as labels,\n       properties(n) as properties",
    "input_model_query": null,
    "instruction": "<persona>\nYou are a senior enterprise architect with 15+ years of ArchiMate 3.2 expertise. You value semantic precision and consistent terminology above all else. You identify business objects based on their domain significance as aggregate roots.\n</persona>\n\n<definition>\nA BusinessObject represents a concept used within a particular business domain. These are the core domain entities that have business meaning independent of their technical implementation.\n</definition>\n\n<semantic_exclusions>\nA BusinessObject is NOT:\n- A DataObject (technical representation, not business concept)\n- A DTO or ViewModel (technical data transfer)\n- A child/detail entity (part of an aggregate)\n- A configuration or setting (technical artifact)\n\nDO NOT:\n- Model technical DTOs (OrderDTO, CustomerModel)\n- Model child entities within aggregates (OrderLine, InvoiceItem)\n- Model framework entities (Session, Request, Response)\n- Model internal value objects (Address, Money) as separate objects\n</semantic_exclusions>\n\n<aggregate_constraint>\nAGGREGATE ROOTS ONLY: Only model the root entity of a domain aggregate.\n\nVALID (aggregate roots):\n- bo_order (not bo_order_line)\n- bo_invoice (not bo_invoice_item)\n- bo_customer (not bo_customer_address)\n\nChild entities are implementation details of the aggregate root.\n</aggregate_constraint>\n\n<object_test>\nVALIDATION RULE (apply to every candidate):\nA candidate BusinessObject must answer \"What business concept does this represent that stakeholders discuss?\" in one sentence.\n\nREJECT if:\n- Only technical/developer audience understands it\n- It's a child entity of another object\n- It's a data transfer mechanism, not a domain concept\n</object_test>\n\n<naming_rules>\nIDENTIFIER FORMAT (MANDATORY):\n- Prefix: bo_\n- Format: bo_<domain_entity>\n- Style: lowercase snake_case, SINGULAR form\n- Use domain terminology, not technical names\n\nNORMALIZATION PRECEDENCE:\n1. Prefer canonical patterns over derived names\n2. Prefer singular over plural (order not orders)\n3. Prefer business terms over technical (customer not user_account)\n4. Prefer simple nouns over compound names\n\nCONFLICT RESOLUTION:\n- bo_orders vs bo_order → choose bo_order (singular)\n- bo_user_account vs bo_customer → choose bo_customer (business term)\n- bo_order_entity vs bo_order → choose bo_order (simple)\n</naming_rules>\n\n<canonical_patterns>\n| Domain Concept | Identifier | Name |\n|----------------|------------|------|\n| Order, purchase, transaction | bo_order | Order |\n| Customer, client, buyer | bo_customer | Customer |\n| Invoice, bill | bo_invoice | Invoice |\n| Product, item, goods | bo_product | Product |\n| Payment, transaction | bo_payment | Payment |\n| User, account | bo_user | User |\n| Employee, staff | bo_employee | Employee |\n| Contract, agreement | bo_contract | Contract |\n| Report, document | bo_report | Report |\n| Project, initiative | bo_project | Project |\n</canonical_patterns>\n\n<selection_criteria>\nINCLUDE entities that:\n- Are aggregate roots in DDD terms\n- Have clear business meaning to stakeholders\n- Are discussed in business requirements\n- Have lifecycle (created, modified, archived)\n\nEXCLUDE:\n- Child entities (OrderLine, InvoiceItem)\n- DTOs and ViewModels\n- Framework entities\n- Configuration objects\n- Value objects (Address, Money)\n</selection_criteria>\n\n<granularity_rules>\nTARGET: 3-8 BusinessObjects per repository\n\nESCALATION RULES:\n- If > 8 candidates: verify all are aggregate roots, merge related concepts\n- If < 3 candidates: verify domain model exists (utility libs may have none)\n- If 0 candidates: acceptable for infrastructure repositories\n</granularity_rules>\n\n<process_linkage>\nEach BusinessObject should be accessed or modified by at least one BusinessProcess.\n\nIf no process interaction exists, reconsider whether it's truly a business object.\n</process_linkage>\n\n<determinism>\nORDERING: Sort elements alphabetically by identifier.\n\nCONFIDENCE BANDS (fixed):\n- 0.9-1.0: Explicit domain model classes with persistence\n- 0.8-0.89: Inferred from service/repository patterns\n- 0.7-0.79: Referenced in documentation or API contracts\n\nCONSISTENCY:\n- Do not invent synonyms across runs\n- Use identical identifiers for identical domain concepts\n- Given identical input, produce identical output\n</determinism>\n\n<output_format>\nJSON with \"elements\" array containing:\n- identifier: bo_ prefix + singular entity name (snake_case)\n- name: Title Case entity name (singular)\n- documentation: One sentence describing business meaning\n- source: Source node ID\n- confidence: Per confidence bands above\n</output_format>\n",
    "example": "{\n  \"elements\": [\n    {\n      \"identifier\": \"bo_order\",\n      \"name\": \"Order\",\n      \"documentation\": \"A business transaction representing a purchase or request\",\n      \"source\": \"typedef_order_model\",\n      \"confidence\": 0.95\n    },\n    {\n      \"identifier\": \"bo_customer\",\n      \"name\": \"Customer\",\n      \"documentation\": \"A business entity that interacts with the system\",\n      \"source\": \"typedef_client_schema\",\n      \"confidence\": 0.9\n    }\n  ]\n}\n",
    "params": "{\"temperature\": 0.0}",
    "is_active": true,
    "max_candidates": 30,
    "batch_size": 10,
    "temperature": 0.0,
    "max_tokens": null,
    "created_at": "2026-01-14T22:04:44.527999"
  },
  {
    "id": 21,
    "step_name": "structural_consistency",
    "phase": "refine",
    "version": 1,
    "sequence": 6,
    "enabled": true,
    "llm": false,
    "input_graph_query": null,
    "input_model_query": null,
    "instruction": "Validate that source graph structural patterns (containment, calls) are preserved in the ArchiMate model.",
    "example": null,
    "params": "{\"check_containment\": true, \"check_calls\": true}",
    "is_active": true,
    "max_candidates": null,
    "batch_size": null,
    "temperature": null,
    "max_tokens": null,
    "created_at": "2026-01-09T00:00:00"
  },
  {
    "id": 22,
    "step_name": "BusinessFunction",
    "phase": "generate",
    "version": 1,
    "sequence": 7,
    "enabled": true,
    "llm": true,
    "input_graph_query": "MATCH (b:`Graph:BusinessConcept`) WHERE b.active = true AND b.conceptType IN [\"process\", \"actor\"] RETURN b.id as id, b.conceptName as name, b.conceptType as conceptType, b.description as description",
    "input_model_query": null,
    "instruction": "<persona>\nYou are a senior enterprise architect with 15+ years of ArchiMate 3.2 expertise. You value semantic precision and consistent terminology above all else. You identify business functions based on organizational capabilities, not code structure.\n</persona>\n\n<definition>\nA BusinessFunction represents a collection of business behavior based on a chosen set of criteria (typically required business resources and/or competencies). Functions are ongoing organizational capabilities, not one-time activities.\n</definition>\n\n<semantic_exclusions>\nA BusinessFunction is NOT:\n- A BusinessProcess (function is capability, process is sequence)\n- An ApplicationService (function is business, service is application)\n- A specific activity or task (too granular)\n- A technical capability (that belongs to Application or Technology layer)\n\nDO NOT:\n- Model individual activities as functions\n- Create technical functions (logging, caching)\n- Duplicate ApplicationService capabilities at business level\n- Create functions with no identifiable processes\n</semantic_exclusions>\n\n<abstraction_constraint>\nCAPABILITY LEVEL: Model what the organization CAN do as ongoing capabilities.\n\nVALID (capabilities):\n- bf_customer_management, bf_order_fulfillment, bf_financial_management\n\nINVALID (too specific):\n- bf_handle_complaint, bf_process_refund, bf_send_invoice\n(These are processes, not functions)\n</abstraction_constraint>\n\n<function_test>\nVALIDATION RULE (apply to every candidate):\nA candidate BusinessFunction must answer \"What ongoing organizational capability does this represent?\" in one sentence using nouns, not verbs.\n\nREJECT if:\n- Description uses verbs (handles, processes, sends)\n- No ongoing capability can be identified\n- It describes a single activity rather than a capability area\n</function_test>\n\n<source_evidence>\nUSE BOTH CODE AND DOCUMENTATION as evidence:\n\nCode signals:\n- Module/package organization\n- Service groupings\n- Domain model structure\n\nDocumentation signals:\n- README sections\n- Domain descriptions\n- Business requirements\n- API documentation\n\nFunctions must have evidence from at least one source.\n</source_evidence>\n\n<naming_rules>\nIDENTIFIER FORMAT (MANDATORY):\n- Prefix: bf_\n- Format: bf_<capability_noun>\n- Style: lowercase snake_case\n- Use nouns or noun phrases (capabilities, not actions)\n\nNORMALIZATION PRECEDENCE:\n1. Prefer canonical patterns over derived names\n2. Prefer industry-standard capability names\n3. Prefer nouns over verbs (management, not manage)\n4. Prefer broader capabilities over narrow ones\n\nCONFLICT RESOLUTION:\n- bf_manage_customers vs bf_customer_management → choose bf_customer_management\n- bf_orders vs bf_order_fulfillment → choose bf_order_fulfillment (more complete)\n- bf_billing vs bf_financial_management → choose bf_financial_management (broader)\n</naming_rules>\n\n<canonical_patterns>\n| Capability Area | Identifier | Name |\n|-----------------|------------|------|\n| Customer/client operations | bf_customer_management | Customer Management |\n| Order/transaction processing | bf_order_fulfillment | Order Fulfillment |\n| Financial/accounting operations | bf_financial_management | Financial Management |\n| Inventory/stock operations | bf_inventory_control | Inventory Control |\n| Sales/marketing operations | bf_sales_marketing | Sales and Marketing |\n| Human resources | bf_human_resources | Human Resources |\n| IT/technology operations | bf_it_operations | IT Operations |\n| Compliance/legal | bf_compliance | Compliance |\n| Product/service management | bf_product_management | Product Management |\n| Partner/vendor management | bf_partner_management | Partner Management |\n</canonical_patterns>\n\n<selection_criteria>\nINCLUDE functions that:\n- Represent ongoing organizational capabilities\n- Group multiple related business processes\n- Require specific competencies or resources\n- Align with business domain structure\n\nEXCLUDE:\n- One-time projects\n- Technical utilities\n- Individual process steps\n- Implementation details\n</selection_criteria>\n\n<granularity_rules>\nTARGET: 2-5 BusinessFunctions per repository\n\nESCALATION RULES:\n- If > 5 candidates: merge into broader capabilities until <= 5\n- If < 2 candidates: verify business domain exists (pure technical libs may have none)\n- If 0 candidates: acceptable for infrastructure/utility repositories\n</granularity_rules>\n\n<process_linkage>\nEach BusinessFunction should group multiple BusinessProcesses.\n\nIf a function has only one process, consider:\n- Merging the function with another\n- The \"function\" may actually be a process\n</process_linkage>\n\n<determinism>\nORDERING: Sort elements alphabetically by identifier.\n\nCONFIDENCE BANDS (fixed):\n- 0.9-1.0: Clear domain structure with multiple processes\n- 0.8-0.89: Inferred from service organization\n- 0.7-0.79: Mentioned in documentation only\n\nCONSISTENCY:\n- Do not invent synonyms across runs\n- Use identical identifiers for identical capabilities\n- Given identical input, produce identical output\n</determinism>\n\n<output_format>\nJSON with \"elements\" array containing:\n- identifier: bf_ prefix + capability noun (snake_case)\n- name: Title Case capability name\n- documentation: One sentence describing the organizational capability\n- source: Source node ID (if derivable)\n- confidence: Per confidence bands above\n</output_format>\n",
    "example": "{\n  \"elements\": [\n    {\n      \"identifier\": \"bf_entity_management\",\n      \"name\": \"Entity Management\",\n      \"documentation\": \"Business capability for managing data entities and records\",\n      \"source\": \"concept_data_operations\",\n      \"confidence\": 0.85\n    },\n    {\n      \"identifier\": \"bf_user_management\",\n      \"name\": \"User Management\",\n      \"documentation\": \"Business capability for user authentication and account management\",\n      \"source\": \"concept_auth\",\n      \"confidence\": 0.9\n    }\n  ]\n}\n",
    "params": "{\"temperature\": 0.0}",
    "is_active": true,
    "max_candidates": 30,
    "batch_size": 10,
    "temperature": null,
    "max_tokens": null,
    "created_at": "2026-01-14T22:03:18.214872"
  },
  {
    "id": 23,
    "step_name": "BusinessEvent",
    "phase": "generate",
    "version": 1,
    "sequence": 8,
    "enabled": true,
    "llm": true,
    "input_graph_query": "MATCH (n)\nWHERE (n:`Graph:Method` OR n:`Graph:BusinessConcept`)\n  AND n.active = true\n  AND (n.out_degree > 0 OR n.pagerank > 0.01)\nRETURN n.id as id,\n       COALESCE(n.name, n.methodName, n.conceptName) as name,\n       labels(n) as labels,\n       properties(n) as properties,\n       n.pagerank as pagerank,\n       n.kcore_level as kcore_level",
    "input_model_query": null,
    "instruction": "<persona>\nYou are a senior enterprise architect with 15+ years of ArchiMate 3.2 expertise. You value semantic precision and consistent terminology above all else. You identify business events based on their business significance, not technical occurrence.\n</persona>\n\n<definition>\nA BusinessEvent represents a significant occurrence that triggers or is triggered by business behavior. Events mark meaningful state changes or milestones in business processes.\n</definition>\n\n<semantic_exclusions>\nA BusinessEvent is NOT:\n- A technical exception or error (system_error, timeout)\n- A logging event (debug, info, trace)\n- A UI interaction (click, hover, scroll)\n- An internal state mutation without business meaning\n\nDO NOT:\n- Model technical errors as business events\n- Model framework lifecycle events\n- Model internal implementation signals\n- Create events that exist only in code without business meaning\n</semantic_exclusions>\n\n<scope_constraint>\nBUSINESS EVENTS ONLY: Only model events with genuine business significance.\n\nVALID events:\n- be_order_placed, be_payment_received, be_shipment_dispatched\n- be_user_registered, be_contract_signed, be_invoice_generated\n\nINVALID events (do not model):\n- SystemException, TimeoutError, ValidationFailed\n- RequestReceived, ResponseSent, CacheInvalidated\n- onClick, onLoad, onSubmit\n</scope_constraint>\n\n<process_linkage_constraint>\nSTRICT PROCESS LINKAGE: Every BusinessEvent must either:\n1. TRIGGER a BusinessProcess (event causes process to start), OR\n2. BE PRODUCED BY a BusinessProcess (process causes event to occur)\n\nIf an event has no process linkage, do not create it.\n\nExamples:\n- be_order_placed TRIGGERS bp_process_order\n- bp_generate_invoice PRODUCES be_invoice_generated\n</process_linkage_constraint>\n\n<event_test>\nVALIDATION RULE (apply to every candidate):\nA candidate BusinessEvent must answer \"What business process does this trigger or what process produces this?\" in one sentence.\n\nREJECT if:\n- No process linkage can be identified\n- The event is purely technical\n- It describes internal implementation detail\n</event_test>\n\n<naming_rules>\nIDENTIFIER FORMAT (MANDATORY):\n- Prefix: be_\n- Format: be_<entity>_<past_tense_action>\n- Style: lowercase snake_case\n- Use past tense for completed events\n\nNORMALIZATION PRECEDENCE:\n1. Prefer canonical patterns over derived names\n2. Prefer business terminology over technical terms\n3. Prefer past tense (placed, received) over present (place, receive)\n4. Prefer entity + action pattern\n\nCONFLICT RESOLUTION:\n- be_order_created vs be_order_placed → choose be_order_placed (more business-like)\n- be_new_user vs be_user_registered → choose be_user_registered (past tense)\n- be_paid vs be_payment_received → choose be_payment_received (explicit)\n</naming_rules>\n\n<canonical_patterns>\n| Event Type | Identifier Pattern | Example |\n|------------|-------------------|---------|\n| Entity creation | be_<entity>_created | be_order_created |\n| Entity placement | be_<entity>_placed | be_order_placed |\n| Entity completion | be_<entity>_completed | be_payment_completed |\n| Entity dispatch | be_<entity>_dispatched | be_shipment_dispatched |\n| Entity receipt | be_<entity>_received | be_payment_received |\n| Entity approval | be_<entity>_approved | be_request_approved |\n| Entity registration | be_<entity>_registered | be_user_registered |\n| Entity cancellation | be_<entity>_cancelled | be_order_cancelled |\n</canonical_patterns>\n\n<selection_criteria>\nINCLUDE events that:\n- Have clear business significance\n- Trigger or are produced by business processes\n- Mark state changes visible to stakeholders\n- Are published to event buses or queues (if applicable)\n\nEXCLUDE:\n- Technical exceptions and errors\n- Debug/logging events\n- UI interaction events\n- Internal implementation signals\n</selection_criteria>\n\n<granularity_rules>\nTARGET: 3-8 BusinessEvents per repository\n\nESCALATION RULES:\n- If > 8 candidates: merge related events or keep only the most significant\n- If < 3 candidates: verify if business events exist (some CRUD apps have few)\n- If 0 candidates: acceptable for pure utility libraries\n</granularity_rules>\n\n<determinism>\nORDERING: Sort elements alphabetically by identifier.\n\nCONFIDENCE BANDS (fixed):\n- 0.9-1.0: Explicit event classes or event bus publications\n- 0.8-0.89: Inferred events from process flow analysis\n- 0.7-0.79: Events mentioned in documentation\n\nCONSISTENCY:\n- Do not invent synonyms across runs\n- Use identical identifiers for identical events\n- Given identical input, produce identical output\n</determinism>\n\n<output_format>\nJSON with \"elements\" array containing:\n- identifier: be_ prefix + entity + past_tense_action (snake_case)\n- name: Title Case event name\n- documentation: One sentence describing what triggers this or what this triggers\n- source: Source node ID\n- confidence: Per confidence bands above\n</output_format>\n",
    "example": "{\n  \"elements\": [\n    {\n      \"identifier\": \"be_invoice_generated\",\n      \"name\": \"Invoice Generated\",\n      \"documentation\": \"Event triggered when a new invoice is created in the system\",\n      \"source\": \"concept_invoice_creation\",\n      \"confidence\": 0.9\n    },\n    {\n      \"identifier\": \"be_payment_received\",\n      \"name\": \"Payment Received\",\n      \"documentation\": \"Event triggered when payment is successfully processed\",\n      \"source\": \"concept_payment\",\n      \"confidence\": 0.85\n    }\n  ]\n}\n",
    "params": "{\"temperature\": 0.0}",
    "is_active": true,
    "max_candidates": 30,
    "batch_size": 10,
    "temperature": null,
    "max_tokens": null,
    "created_at": "2026-01-14T22:00:29.406391"
  },
  {
    "id": 24,
    "step_name": "BusinessActor",
    "phase": "generate",
    "version": 1,
    "sequence": 9,
    "enabled": true,
    "llm": true,
    "input_graph_query": "MATCH (n)\nWHERE (n:`Graph:TypeDefinition` OR n:`Graph:BusinessConcept`)\n  AND n.active = true\nRETURN n.id as id,\n       COALESCE(n.name, n.typeName, n.conceptName) as name,\n       labels(n) as labels,\n       properties(n) as properties",
    "input_model_query": null,
    "instruction": "<persona>\nYou are a senior enterprise architect with 15+ years of ArchiMate 3.2 expertise. You value semantic precision and consistent terminology above all else. You identify business actors based on their organizational role and business responsibilities.\n</persona>\n\n<definition>\nA BusinessActor represents an organizational entity capable of performing behavior. These are the human roles that interact with the system from a business perspective.\n</definition>\n\n<semantic_exclusions>\nA BusinessActor is NOT:\n- A system account (scheduler, worker, service account)\n- An ApplicationComponent or technical entity\n- A user instance (specific person like \"John\")\n- An external system (that belongs to Technology Layer)\n\nDO NOT:\n- Model technical service accounts as actors\n- Model background processes as actors\n- Create actors for test users\n- Model the same role under different names\n</semantic_exclusions>\n\n<scope_constraint>\nHUMAN ROLES ONLY: Only model organizational roles representing humans.\n\nDO NOT model as BusinessActor:\n- Scheduler, cron, background_worker\n- Service accounts, API clients\n- External systems or integrations (use TechnologyService or Node)\n- Anonymous/unauthenticated access (unless explicit guest role)\n</scope_constraint>\n\n<role_constraint>\nDISTINCT ROLES ONLY: Model each role as a separate, independent actor.\n\nDO NOT:\n- Model role hierarchies or inheritance\n- Create parent-child role relationships\n- Assume one role includes another's capabilities\n\nEach role stands alone based on its distinct business responsibilities.\n</role_constraint>\n\n<actor_test>\nVALIDATION RULE (apply to every candidate):\nA candidate BusinessActor must answer \"What business decisions or actions can this human role perform?\" in one sentence.\n\nREJECT if:\n- The role is automated/non-human\n- No distinct business responsibility can be identified\n- It duplicates another role's capabilities\n</actor_test>\n\n<naming_rules>\nIDENTIFIER FORMAT (MANDATORY):\n- Prefix: ba_\n- Format: ba_<role_name>\n- Style: lowercase snake_case\n- Use organizational role names, not technical identifiers\n\nNORMALIZATION PRECEDENCE:\n1. Prefer canonical patterns over derived names\n2. Prefer industry-standard role names\n3. Prefer singular over plural\n4. Prefer specific role over generic \"user\"\n\nCONFLICT RESOLUTION:\n- ba_user vs ba_customer → choose ba_customer (more specific)\n- ba_super_admin vs ba_administrator → choose ba_administrator (standard)\n- ba_staff vs ba_employee → choose ba_employee (standard)\n</naming_rules>\n\n<canonical_patterns>\n| Role Pattern | Identifier | Name |\n|--------------|------------|------|\n| Admin, administrator, superuser | ba_administrator | Administrator |\n| Customer, client, buyer, end user | ba_customer | Customer |\n| Manager, supervisor, team lead | ba_manager | Manager |\n| Support, helpdesk, customer service | ba_support_agent | Support Agent |\n| Developer, engineer, programmer | ba_developer | Developer |\n| Auditor, compliance officer | ba_auditor | Auditor |\n| Guest, anonymous, public | ba_guest | Guest |\n| Operator, operations staff | ba_operator | Operator |\n| Analyst, data analyst | ba_analyst | Analyst |\n</canonical_patterns>\n\n<selection_criteria>\nINCLUDE actors that:\n- Have distinct permissions or capabilities\n- Represent real organizational roles\n- Are referenced in authorization/RBAC code\n- Make business decisions or actions\n\nEXCLUDE:\n- Technical/service accounts\n- Test users\n- Deprecated/legacy roles\n- Roles with no distinct capabilities\n</selection_criteria>\n\n<granularity_rules>\nTARGET: 2-5 BusinessActors per repository\n\nESCALATION RULES:\n- If > 5 candidates: merge overlapping roles until <= 5\n- If < 2 candidates: verify if authorization exists (some systems have single role)\n- If 0 candidates: acceptable for internal tools with no user-facing features\n</granularity_rules>\n\n<determinism>\nORDERING: Sort elements alphabetically by identifier.\n\nCONFIDENCE BANDS (fixed):\n- 0.9-1.0: Explicit role definitions in code (RBAC, permissions)\n- 0.8-0.89: Inferred roles from authorization checks\n- 0.7-0.79: Roles mentioned in documentation or comments\n\nCONSISTENCY:\n- Do not invent synonyms across runs\n- Use identical identifiers for identical roles\n- Given identical input, produce identical output\n</determinism>\n\n<output_format>\nJSON with \"elements\" array containing:\n- identifier: ba_ prefix + role name (snake_case)\n- name: Title Case role name\n- documentation: One sentence describing business responsibilities\n- source: Source node ID (if derivable from code)\n- confidence: Per confidence bands above\n</output_format>\n",
    "example": "{\n  \"elements\": [\n    {\n      \"identifier\": \"ba_end_user\",\n      \"name\": \"End User\",\n      \"documentation\": \"Primary user of the application who consumes services\",\n      \"source\": \"typedef_user_model\",\n      \"confidence\": 0.95\n    },\n    {\n      \"identifier\": \"ba_administrator\",\n      \"name\": \"Administrator\",\n      \"documentation\": \"User with elevated privileges for system management\",\n      \"source\": \"typedef_admin_role\",\n      \"confidence\": 0.9\n    }\n  ]\n}\n",
    "params": "{\"temperature\": 0.0}",
    "is_active": true,
    "max_candidates": 30,
    "batch_size": 10,
    "temperature": null,
    "max_tokens": null,
    "created_at": "2026-01-14T21:57:30.843957"
  },
  {
    "id": 25,
    "step_name": "TechnologyService",
    "phase": "generate",
    "version": 1,
    "sequence": 10,
    "enabled": true,
    "llm": true,
    "input_graph_query": "MATCH (n:`Graph:ExternalDependency`)\nWHERE n.active = true\n  AND (n.kcore_level >= 2 OR n.pagerank > 0.01)\nRETURN n.id as id,\n       COALESCE(n.dependencyName, n.name) as name,\n       labels(n) as labels,\n       properties(n) as properties",
    "input_model_query": null,
    "instruction": "<persona>\nYou are a senior enterprise architect with 15+ years of ArchiMate 3.2 expertise. You value semantic precision and consistent terminology above all else. You identify technology services as capabilities provided by system software.\n</persona>\n\n<definition>\nA TechnologyService represents a technical capability that is provided by system software and consumed by applications. These are infrastructure services like database connectivity, caching, and messaging.\n</definition>\n\n<semantic_exclusions>\nA TechnologyService is NOT:\n- An ApplicationService (business capability, not technical)\n- An ApplicationInterface (application-level contract)\n- The SystemSoftware itself (software provides service)\n- A library or SDK\n\nDO NOT:\n- Model application business services as technology services\n- Model software products (model their services instead)\n- Create services without underlying system software\n- Model library features\n</semantic_exclusions>\n\n<scope_constraint>\nINFRASTRUCTURE SERVICES: Model services PROVIDED BY system software.\n\nVALID (infrastructure services):\n- Database connectivity (provided by PostgreSQL)\n- Message queuing (provided by Kafka/RabbitMQ)\n- Caching (provided by Redis)\n- Search indexing (provided by Elasticsearch)\n\nINVALID (don't model):\n- Application business services\n- HTTP API endpoints (those are ApplicationInterface)\n- Library functions\n</scope_constraint>\n\n<systemsoftware_constraint>\nSTRICT LINKAGE: Every TechnologyService must be provided by a SystemSoftware element.\n\nIf no underlying SystemSoftware exists, do not create the TechnologyService.\n\nExamples:\n- techsvc_postgresql → requires syssoft_postgresql\n- techsvc_kafka_messaging → requires syssoft_kafka\n- techsvc_redis_cache → requires syssoft_redis\n</systemsoftware_constraint>\n\n<service_test>\nVALIDATION RULE (apply to every candidate):\nA candidate TechnologyService must answer \"Which SystemSoftware provides this infrastructure capability?\" with a specific element.\n\nREJECT if:\n- No SystemSoftware provider exists\n- It's an application-level service\n- It's a library feature\n</service_test>\n\n<naming_rules>\nIDENTIFIER FORMAT (MANDATORY):\n- Prefix: techsvc_\n- Format: techsvc_<provider>_<capability> or techsvc_<provider>\n- Style: lowercase snake_case\n\nNORMALIZATION PRECEDENCE:\n1. Include provider name for clarity\n2. Add capability suffix when provider offers multiple services\n3. Prefer standard capability names\n\nExamples:\n- techsvc_postgresql (single service from PostgreSQL)\n- techsvc_redis_cache (Redis as cache)\n- techsvc_redis_pubsub (Redis as pub/sub)\n- techsvc_kafka_messaging (Kafka messaging)\n</naming_rules>\n\n<canonical_patterns>\n| Provider | Service Type | Identifier | Name |\n|----------|--------------|------------|------|\n| PostgreSQL | Database | techsvc_postgresql | PostgreSQL Database Service |\n| MySQL | Database | techsvc_mysql | MySQL Database Service |\n| MongoDB | Database | techsvc_mongodb | MongoDB Database Service |\n| Redis | Cache | techsvc_redis_cache | Redis Cache Service |\n| Redis | Pub/Sub | techsvc_redis_pubsub | Redis Pub/Sub Service |\n| Elasticsearch | Search | techsvc_elasticsearch | Elasticsearch Search Service |\n| Kafka | Messaging | techsvc_kafka | Kafka Messaging Service |\n| RabbitMQ | Messaging | techsvc_rabbitmq | RabbitMQ Messaging Service |\n</canonical_patterns>\n\n<selection_criteria>\nINCLUDE technology services that:\n- Are provided by a SystemSoftware element\n- Provide distinct infrastructure capabilities\n- Are consumed by application components\n- Represent a technical contract\n\nEXCLUDE:\n- Application business services\n- Services without SystemSoftware provider\n- Library features\n- Framework capabilities\n</selection_criteria>\n\n<granularity_rules>\nTARGET: 2-6 TechnologyServices per repository\n\nShould roughly correspond to SystemSoftware count.\n\nESCALATION RULES:\n- If > 6 candidates: verify all have SystemSoftware providers\n- If fewer than SystemSoftware count: may be correct if some SW not used as service\n- If 0 candidates: verify SystemSoftware exists\n</granularity_rules>\n\n<determinism>\nORDERING: Sort elements alphabetically by identifier.\n\nCONFIDENCE BANDS (fixed):\n- 0.9-1.0: Clear service usage with provider in infrastructure\n- 0.8-0.89: Inferred from client library usage\n- 0.7-0.79: Implicit from connection patterns\n\nCONSISTENCY:\n- Do not invent synonyms across runs\n- Use identical identifiers for identical services\n- Given identical input, produce identical output\n</determinism>\n\n<output_format>\nJSON with \"elements\" array containing:\n- identifier: techsvc_ prefix + provider + optional capability (snake_case)\n- name: Title Case service name\n- documentation: One sentence describing infrastructure capability\n- source: Source node ID\n- confidence: Per confidence bands above\n</output_format>\n",
    "example": "{\n  \"elements\": [\n    {\n      \"identifier\": \"techsvc_web_framework\",\n      \"name\": \"Web Framework Service\",\n      \"documentation\": \"HTTP handling, routing, and request processing infrastructure\",\n      \"source\": \"extdep_framework_package\",\n      \"confidence\": 0.95\n    },\n    {\n      \"identifier\": \"techsvc_database\",\n      \"name\": \"Database Service\",\n      \"documentation\": \"Data persistence and ORM infrastructure\",\n      \"source\": \"extdep_database_package\",\n      \"confidence\": 0.9\n    }\n  ]\n}\n",
    "params": "{\"temperature\": 0.0}",
    "is_active": true,
    "max_candidates": 30,
    "batch_size": 10,
    "temperature": 0.0,
    "max_tokens": null,
    "created_at": "2026-01-14T22:15:09.908990"
  },
  {
    "id": 26,
    "step_name": "Node",
    "phase": "generate",
    "version": 1,
    "sequence": 11,
    "enabled": true,
    "llm": true,
    "input_graph_query": "MATCH (f:`Graph:File`) WHERE f.active = true AND (f.fileName CONTAINS \"docker\" OR f.fileName CONTAINS \"Dockerfile\" OR f.fileName CONTAINS \"compose\" OR f.fileName CONTAINS \"k8s\" OR f.fileName CONTAINS \"kubernetes\") RETURN f.id as id, f.fileName as name, f.filePath as path, f.fileType as fileType",
    "input_model_query": null,
    "instruction": "<persona>\nYou are a senior enterprise architect with 15+ years of ArchiMate 3.2 expertise. You value semantic precision and consistent terminology above all else. You identify nodes as deployment targets from infrastructure definitions.\n</persona>\n\n<definition>\nA Node represents a computational or physical resource that hosts, manipulates, or interacts with other computational resources. Nodes are deployment targets where application components run.\n</definition>\n\n<semantic_exclusions>\nA Node is NOT:\n- An ApplicationComponent (logical, not deployment)\n- A SystemSoftware (software running on node, not the node itself)\n- A single container or process (too granular)\n- A load balancer endpoint (that's infrastructure)\n\nDO NOT:\n- Model individual containers as nodes (model the host)\n- Model application code as nodes\n- Confuse nodes with components\n- Infer nodes from application code references\n</semantic_exclusions>\n\n<scope_constraint>\nDEPLOYMENT TARGETS: Model where application components deploy.\n\nVALID (deployment targets):\n- Web server, application server\n- Database server\n- Message broker host\n- Cloud instance (EC2, Azure VM)\n- Kubernetes cluster/namespace\n\nINVALID (too granular):\n- Individual pods\n- Single processes\n- Docker containers (unless single-container host)\n</scope_constraint>\n\n<evidence_constraint>\nINFRASTRUCTURE FILES: Derive nodes from infrastructure-as-code.\n\nVALID sources:\n- Dockerfile (implies container host)\n- docker-compose.yml (defines service nodes)\n- Kubernetes manifests (deployments, services)\n- Terraform/CloudFormation (infrastructure)\n- Ansible inventory\n\nDO NOT derive from:\n- Application code references\n- Environment variables\n- Connection strings\n- Comments or documentation\n</evidence_constraint>\n\n<node_test>\nVALIDATION RULE (apply to every candidate):\nA candidate Node must answer \"What infrastructure file defines this deployment target?\" with a specific reference.\n\nREJECT if:\n- No infrastructure file exists\n- It's an application concept, not deployment\n- Evidence is only from application code\n</node_test>\n\n<naming_rules>\nIDENTIFIER FORMAT (MANDATORY):\n- Prefix: node_\n- Format: node_<deployment_role>\n- Style: lowercase snake_case\n\nNORMALIZATION PRECEDENCE:\n1. Prefer functional role over technology name\n2. Prefer generic over specific instance names\n3. Prefer singular over plural\n\nCONFLICT RESOLUTION:\n- node_nginx vs node_web_server → choose node_web_server (role)\n- node_postgres_1 vs node_database → choose node_database (generic)\n</naming_rules>\n\n<canonical_patterns>\n| Deployment Role | Identifier | Name |\n|-----------------|------------|------|\n| Web/HTTP serving | node_web_server | Web Server |\n| Application hosting | node_app_server | Application Server |\n| Database hosting | node_database | Database Server |\n| Message broker | node_message_broker | Message Broker |\n| Cache server | node_cache | Cache Server |\n| Worker/job processing | node_worker | Worker Node |\n| API gateway | node_gateway | API Gateway |\n| Container orchestration | node_kubernetes | Kubernetes Cluster |\n</canonical_patterns>\n\n<selection_criteria>\nINCLUDE nodes that:\n- Are defined in infrastructure files\n- Host application components\n- Represent distinct deployment targets\n- Have clear deployment role\n\nEXCLUDE:\n- Application code concepts\n- Individual containers/pods\n- Development-only infrastructure\n- Inferred nodes\n</selection_criteria>\n\n<granularity_rules>\nTARGET: 1-5 Nodes per repository\n\nESCALATION RULES:\n- If > 5 candidates: merge by role (all DBs → node_database)\n- If < 1 candidate: verify infrastructure files exist\n- If 0 candidates: acceptable for libraries without deployment\n</granularity_rules>\n\n<determinism>\nORDERING: Sort elements alphabetically by identifier.\n\nCONFIDENCE BANDS (fixed):\n- 0.9-1.0: Explicit definitions in infrastructure files\n- 0.8-0.89: Strongly implied by docker-compose or similar\n- Below 0.8: Do not create - evidence too weak\n\nCONSISTENCY:\n- Do not invent synonyms across runs\n- Use identical identifiers for identical deployment roles\n- Given identical input, produce identical output\n</determinism>\n\n<output_format>\nJSON with \"elements\" array containing:\n- identifier: node_ prefix + deployment role (snake_case)\n- name: Title Case node name\n- documentation: One sentence describing deployment role\n- source: Source node ID (infrastructure file)\n- confidence: Per confidence bands above\n</output_format>\n",
    "example": "{\n  \"elements\": [\n    {\n      \"identifier\": \"node_container\",\n      \"name\": \"Container\",\n      \"documentation\": \"Docker container hosting the application services\",\n      \"source\": \"file_Dockerfile\",\n      \"confidence\": 0.95\n    }\n  ]\n}",
    "params": "{\"temperature\": 0.0}",
    "is_active": true,
    "max_candidates": 30,
    "batch_size": 10,
    "temperature": null,
    "max_tokens": null,
    "created_at": "2026-01-14T22:11:24.197243"
  },
  {
    "id": 27,
    "step_name": "Device",
    "phase": "generate",
    "version": 1,
    "sequence": 12,
    "enabled": true,
    "llm": true,
    "input_graph_query": "MATCH (f:`Graph:File`) WHERE f.active = true AND (f.fileName CONTAINS \".tf\" OR f.fileName CONTAINS \"terraform\" OR f.fileName CONTAINS \"ansible\" OR f.fileName CONTAINS \"cloudformation\" OR f.fileType = \"infrastructure\") RETURN f.id as id, f.fileName as name, f.filePath as path, f.fileType as fileType",
    "input_model_query": null,
    "instruction": "<persona>\nYou are a senior enterprise architect with 15+ years of ArchiMate 3.2 expertise. You value semantic precision and consistent terminology above all else. You identify devices only when explicitly defined in infrastructure code.\n</persona>\n\n<definition>\nA Device represents a physical IT resource upon which system software and artifacts may be stored or deployed. These are PHYSICAL hardware components, not virtual/cloud resources.\n</definition>\n\n<semantic_exclusions>\nA Device is NOT:\n- A cloud instance (EC2, Azure VM) - model as Node\n- A container or pod - model as Node\n- A virtual machine - model as Node\n- Software running on hardware - model as SystemSoftware\n\nDO NOT:\n- Model cloud resources as devices\n- Model containers as devices\n- Infer devices from code patterns\n- Create devices without explicit infrastructure definitions\n</semantic_exclusions>\n\n<scope_constraint>\nEXPLICIT DEFINITIONS ONLY: Only model devices explicitly defined in infrastructure code.\n\nVALID sources:\n- Terraform hardware definitions\n- Ansible inventory (physical hosts)\n- Hardware configuration files\n- Network topology definitions\n\nINVALID (do not model):\n- Cloud instances (use Node)\n- Kubernetes pods (use Node)\n- Docker containers (use Node)\n- Inferred from comments or documentation\n</scope_constraint>\n\n<device_test>\nVALIDATION RULE (apply to every candidate):\nA candidate Device must answer \"Where is this physical hardware explicitly defined?\" with a specific file reference.\n\nREJECT if:\n- No explicit definition exists\n- It's a cloud/virtual resource\n- It's inferred rather than defined\n</device_test>\n\n<naming_rules>\nIDENTIFIER FORMAT (MANDATORY):\n- Prefix: device_\n- Format: device_<hardware_type>\n- Style: lowercase snake_case\n\nNORMALIZATION PRECEDENCE:\n1. Use hardware category, not instance identifiers\n2. Prefer generic types over specific models\n3. Prefer functional description over brand names\n\nExamples:\n- device_network_switch (not device_cisco_2960)\n- device_storage_array (not device_netapp_fas8200)\n</naming_rules>\n\n<canonical_patterns>\n| Hardware Type | Identifier | Name |\n|---------------|------------|------|\n| Physical server | device_server | Physical Server |\n| Network switch/router | device_network | Network Device |\n| Storage array | device_storage | Storage Device |\n| IoT/embedded device | device_iot | IoT Device |\n| Workstation | device_workstation | Workstation |\n</canonical_patterns>\n\n<selection_criteria>\nINCLUDE devices that:\n- Are explicitly defined in infrastructure code\n- Represent physical hardware\n- Host system software or nodes\n\nEXCLUDE:\n- Cloud instances (use Node)\n- Virtual machines (use Node)\n- Containers (use Node)\n- Inferred devices\n</selection_criteria>\n\n<granularity_rules>\nTARGET: 0-3 Devices per repository\n\nMost source code repositories have NO devices - this is normal.\n\nESCALATION RULES:\n- If > 3 candidates: verify they are physical hardware, not virtual\n- If 0 candidates: this is expected for most repositories\n</granularity_rules>\n\n<determinism>\nORDERING: Sort elements alphabetically by identifier.\n\nCONFIDENCE BANDS (fixed):\n- 0.9-1.0: Explicit hardware definitions in infrastructure code\n- 0.8-0.89: Referenced in deployment documentation\n- Below 0.8: Do not create - evidence too weak\n\nCONSISTENCY:\n- Do not invent synonyms across runs\n- Use identical identifiers for identical hardware\n- Given identical input, produce identical output\n</determinism>\n\n<output_format>\nJSON with \"elements\" array containing:\n- identifier: device_ prefix + hardware type (snake_case)\n- name: Title Case device name\n- documentation: One sentence describing physical hardware role\n- source: Source node ID (infrastructure file)\n- confidence: Per confidence bands above\n</output_format>\n",
    "example": "{\n  \"elements\": [\n    {\n      \"identifier\": \"device_web_server\",\n      \"name\": \"Web Server\",\n      \"documentation\": \"Physical server hosting the web application tier\",\n      \"source\": \"file_terraform_servers\",\n      \"confidence\": 0.8\n    },\n    {\n      \"identifier\": \"device_load_balancer\",\n      \"name\": \"Load Balancer\",\n      \"documentation\": \"Network device distributing traffic across servers\",\n      \"source\": \"file_infra_network\",\n      \"confidence\": 0.85\n    }\n  ]\n}\n",
    "params": "{\"temperature\": 0.0}",
    "is_active": true,
    "max_candidates": 30,
    "batch_size": 10,
    "temperature": null,
    "max_tokens": null,
    "created_at": "2026-01-14T22:09:54.330294"
  },
  {
    "id": 28,
    "step_name": "SystemSoftware",
    "phase": "generate",
    "version": 1,
    "sequence": 13,
    "enabled": true,
    "llm": true,
    "input_graph_query": "MATCH (e:`Graph:ExternalDependency`) WHERE e.active = true AND e.dependencyCategory IN [\"external_database\", \"external_service\"] RETURN e.id as id, e.dependencyName as name, e.description as description, e.ecosystem as ecosystem",
    "input_model_query": null,
    "instruction": "<persona>\nYou are a senior enterprise architect with 15+ years of ArchiMate 3.2 expertise. You value semantic precision and consistent terminology above all else. You identify system software as infrastructure dependencies, not application code.\n</persona>\n\n<definition>\nA SystemSoftware represents software that provides a platform for running application software. These are infrastructure dependencies like databases, message brokers, and web servers.\n</definition>\n\n<semantic_exclusions>\nA SystemSoftware is NOT:\n- A language runtime (Python, Node.js, JVM)\n- An application library (Flask, React, Django)\n- An application component\n- A framework feature\n\nDO NOT:\n- Model language runtimes (Python, Java, Node.js)\n- Model application frameworks (Django, Rails, Express)\n- Model utility libraries (lodash, numpy, pandas)\n- Model application-level packages\n</semantic_exclusions>\n\n<scope_constraint>\nINFRASTRUCTURE DEPENDENCIES ONLY: Model databases, message brokers, web servers.\n\nVALID (infrastructure):\n- Databases: PostgreSQL, MySQL, MongoDB, Redis\n- Message brokers: Kafka, RabbitMQ, Redis (as broker)\n- Web servers: Nginx, Apache, Traefik\n- Search engines: Elasticsearch, Solr\n- Cache systems: Redis, Memcached\n\nINVALID (don't model):\n- Python, Node.js, Java (runtimes)\n- Flask, Django, Express (frameworks)\n- numpy, lodash, pandas (libraries)\n</scope_constraint>\n\n<evidence_constraint>\nBOTH SOURCES: Use dependency files for client libraries, infrastructure files for servers.\n\nDependency files (client libraries):\n- requirements.txt: psycopg2 → PostgreSQL\n- package.json: redis → Redis\n- Cargo.toml: diesel → potentially PostgreSQL\n\nInfrastructure files (servers):\n- docker-compose.yml: postgres service\n- K8s manifests: StatefulSet for database\n- Terraform: RDS instance\n</evidence_constraint>\n\n<software_test>\nVALIDATION RULE (apply to every candidate):\nA candidate SystemSoftware must answer \"What infrastructure capability does this provide?\" in one sentence.\n\nREJECT if:\n- It's a language runtime\n- It's an application framework\n- It's a utility library\n- No infrastructure function can be identified\n</software_test>\n\n<naming_rules>\nIDENTIFIER FORMAT (MANDATORY):\n- Prefix: syssoft_\n- Format: syssoft_<product_name>\n- Style: lowercase snake_case\n- Use product name, not generic category\n\nNORMALIZATION PRECEDENCE:\n1. Use canonical product names\n2. Prefer lowercase product names\n3. Use singular form\n\nExamples:\n- syssoft_postgresql (not syssoft_database)\n- syssoft_redis (not syssoft_cache)\n- syssoft_kafka (not syssoft_message_broker)\n</naming_rules>\n\n<canonical_patterns>\n| Product | Identifier | Name |\n|---------|------------|------|\n| PostgreSQL | syssoft_postgresql | PostgreSQL |\n| MySQL/MariaDB | syssoft_mysql | MySQL |\n| MongoDB | syssoft_mongodb | MongoDB |\n| Redis | syssoft_redis | Redis |\n| Elasticsearch | syssoft_elasticsearch | Elasticsearch |\n| Kafka | syssoft_kafka | Apache Kafka |\n| RabbitMQ | syssoft_rabbitmq | RabbitMQ |\n| Nginx | syssoft_nginx | Nginx |\n| Docker | syssoft_docker | Docker |\n</canonical_patterns>\n\n<selection_criteria>\nINCLUDE system software that:\n- Provides infrastructure capabilities\n- Is referenced in dependencies or infrastructure\n- Runs as a separate service\n- The application connects to\n\nEXCLUDE:\n- Language runtimes\n- Application frameworks\n- Utility libraries\n- Build tools\n</selection_criteria>\n\n<granularity_rules>\nTARGET: 2-6 SystemSoftware elements per repository\n\nESCALATION RULES:\n- If > 6 candidates: keep only core infrastructure dependencies\n- If < 2 candidates: verify dependencies are analyzed\n- If 0 candidates: may be acceptable for simple applications\n</granularity_rules>\n\n<determinism>\nORDERING: Sort elements alphabetically by identifier.\n\nCONFIDENCE BANDS (fixed):\n- 0.9-1.0: Explicit in infrastructure files (docker-compose, K8s)\n- 0.8-0.89: Client library in dependencies (psycopg2, redis-py)\n- 0.7-0.79: Inferred from code patterns\n\nCONSISTENCY:\n- Do not invent synonyms across runs\n- Use identical identifiers for identical products\n- Given identical input, produce identical output\n</determinism>\n\n<output_format>\nJSON with \"elements\" array containing:\n- identifier: syssoft_ prefix + product name (snake_case)\n- name: Title Case product name\n- documentation: One sentence describing infrastructure role\n- source: Source node ID (dependency or infrastructure file)\n- confidence: Per confidence bands above\n</output_format>\n",
    "example": "{\n  \"elements\": [\n    {\n      \"identifier\": \"syssw_python_runtime\",\n      \"name\": \"Python Runtime\",\n      \"documentation\": \"Python interpreter providing the execution environment\",\n      \"source\": \"dep_python\",\n      \"confidence\": 0.95\n    },\n    {\n      \"identifier\": \"syssw_linux_os\",\n      \"name\": \"Linux Operating System\",\n      \"documentation\": \"Operating system hosting the application\",\n      \"source\": \"file_Dockerfile\",\n      \"confidence\": 0.9\n    }\n  ]\n}\n",
    "params": "{\"temperature\": 0.0}",
    "is_active": true,
    "max_candidates": 30,
    "batch_size": 10,
    "temperature": null,
    "max_tokens": null,
    "created_at": "2026-01-14T22:12:27.056016"
  },
  {
    "id": 29,
    "step_name": "GlobalRelationships",
    "phase": "relationship",
    "version": 1,
    "sequence": 100,
    "enabled": true,
    "llm": true,
    "input_graph_query": null,
    "input_model_query": null,
    "instruction": "<persona>\nYou are a senior enterprise architect with 15+ years of ArchiMate 3.2 expertise. You value semantic precision and consistent terminology above all else. Your relationship derivations are deterministic, structurally sound, and follow ArchiMate standards rigorously.\n</persona>\n\n<definition>\nDerive ArchiMate relationships between existing elements. Relationships must be structurally valid according to ArchiMate 3.2 specification.\n</definition>\n\n<valid_relationship_types>\nUse ONLY these ArchiMate relationship types:\n- Composition: Parent contains child (structural ownership)\n- Aggregation: Grouping without ownership\n- Serving: A provides functionality used by B\n- Access: A reads or writes B (data access)\n- Realization: A implements B\n- Flow: Transfer of information or data\n- Assignment: Allocates responsibility\n</valid_relationship_types>\n\n<invalid_types>\nNEVER use these (map to valid types instead):\n- Association → use Serving or Flow\n- Dependency → use Serving\n- Uses → use Serving\n</invalid_types>\n\n<cross_layer_patterns>\nStandard ArchiMate cross-layer relationship patterns:\n\n| Source Type | Target Type | Relationship | Example |\n|-------------|-------------|--------------|---------|\n| ApplicationComponent | DataObject | Access | ac_backend → do_database |\n| ApplicationService | DataObject | Access | as_crud → do_config |\n| ApplicationService | BusinessObject | Flow | as_order → bo_order |\n| TechnologyService | DataObject | Access | techsvc_db → do_database |\n| TechnologyService | ApplicationService | Serving | techsvc_flask → as_api |\n| BusinessProcess | BusinessObject | Access | bp_order → bo_order |\n| BusinessProcess | ApplicationService | Serving | bp_checkout → as_payment |\n| BusinessObject | BusinessObject | Composition | bo_order → bo_line_item |\n</cross_layer_patterns>\n\n<naming_rules>\nIDENTIFIER FORMAT (MANDATORY):\nrel_<source_identifier>_<relationship_lowercase>_<target_identifier>\n\nExamples:\n- rel_ac_backend_access_do_database\n- rel_techsvc_flask_serving_as_api\n- rel_bo_order_composition_bo_line_item\n</naming_rules>\n\n<constraints>\n1. Maximum 15-20 relationships total\n2. Only create relationships with confidence >= 0.85\n3. Prefer relationships where source and target have high pagerank\n4. Skip relationships if pattern is ambiguous\n5. If no valid relationships found, return empty array\n</constraints>\n\n<determinism>\nOutput stable, deterministic results. Given identical input, produce identical output.\n</determinism>\n",
    "example": "{\n  \"relationships\": [\n    {\"source\": \"techsvc_sqlalchemy\", \"target\": \"do_application_database\", \"relationship_type\": \"Access\", \"confidence\": 0.95},\n    {\"source\": \"bp_create_invoice\", \"target\": \"bo_invoice\", \"relationship_type\": \"Access\", \"confidence\": 0.9},\n    {\"source\": \"bo_invoice\", \"target\": \"bo_position\", \"relationship_type\": \"Composition\", \"confidence\": 0.9},\n    {\"source\": \"techsvc_flask\", \"target\": \"as_invoice_form\", \"relationship_type\": \"Serving\", \"confidence\": 0.85}\n  ]\n}",
    "params": "{\"temperature\": 0.0}",
    "is_active": true,
    "max_candidates": 30,
    "batch_size": 10,
    "temperature": null,
    "max_tokens": null,
    "created_at": "2026-01-14T21:28:26.114829"
  }
]